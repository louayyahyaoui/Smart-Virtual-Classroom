'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".rmsc{--rmsc-main:#4285f4;--rmsc-hover:#f1f3f5;--rmsc-selected:#e2e6ea;--rmsc-border:#ccc;--rmsc-gray:#aaa;--rmsc-bg:#fff;--rmsc-p:10px;--rmsc-radius:4px;--rmsc-h:38px}.rmsc *{box-sizing:border-box;transition:all .2s ease}.rmsc .gray{color:var(--rmsc-gray)}.rmsc .dropdown-content{position:absolute;z-index:1;top:100%;width:100%;padding-top:8px}.rmsc .dropdown-content .panel-content{overflow:hidden;border-radius:var(--rmsc-radius);background:var(--rmsc-bg);box-shadow:0 0 0 1px rgba(0,0,0,.1),0 4px 11px rgba(0,0,0,.1)}.rmsc .dropdown-container{position:relative;outline:0;background-color:var(--rmsc-bg);border:1px solid var(--rmsc-border);border-radius:var(--rmsc-radius)}.rmsc .dropdown-container:focus-within{box-shadow:var(--rmsc-main) 0 0 0 1px;border-color:var(--rmsc-main)}.rmsc .dropdown-heading{position:relative;padding:0 var(--rmsc-p);display:flex;align-items:center;width:100%;height:var(--rmsc-h);cursor:default;outline:0}.rmsc .dropdown-heading .dropdown-heading-value{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1}.rmsc .clear-selected-button{cursor:pointer;background:none;border:0;padding:0;display:flex}.rmsc .options{max-height:260px;overflow-y:auto;margin:0;padding-left:0}.rmsc .options li{list-style:none;margin:0}.rmsc .select-item{box-sizing:border-box;cursor:pointer;display:block;padding:var(--rmsc-p);outline:0}.rmsc .select-item:focus,.rmsc .select-item:hover{background:var(--rmsc-hover)}.rmsc .select-item.selected{background:var(--rmsc-selected)}.rmsc .no-options{padding:var(--rmsc-p);text-align:center;color:var(--rmsc-gray)}.rmsc .search{width:100%;position:relative;border-bottom:1px solid var(--rmsc-border)}.rmsc .search input{height:var(--rmsc-h);padding:0 var(--rmsc-p);width:100%;outline:0;border:0}.rmsc .search-clear-button{cursor:pointer;position:absolute;top:0;right:0;bottom:0;background:none;border:0;padding:0 calc(var(--rmsc-p)/2)}.rmsc .search-clear-button [hidden]{display:none}.rmsc .item-renderer{display:flex;align-items:baseline}.rmsc .item-renderer input{margin:0 5px 0 0}.rmsc .item-renderer.disabled{opacity:.5}.rmsc .spinner{animation:rotate 2s linear infinite}.rmsc .spinner .path{stroke:var(--rmsc-border);stroke-width:4px;stroke-linecap:round;animation:dash 1.5s ease-in-out infinite}@keyframes rotate{to{transform:rotate(1turn)}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}to{stroke-dasharray:90,150;stroke-dashoffset:-124}}";
styleInject(css_248z);

const defaultStrings = {
  allItemsAreSelected: "All items are selected.",
  clearSearch: "Clear Search",
  clearSelected: "Clear Selected",
  noOptions: "No options",
  search: "Search",
  selectAll: "Select All",
  selectSomeItems: "Select..."
};
const defaultProps = {
  value: [],
  hasSelectAll: true,
  className: "multi-select",
  debounceDuration: 200,
  options: []
};
const MultiSelectContext = /*#__PURE__*/React__default.createContext({});
const MultiSelectProvider = ({
  props,
  children
}) => {
  const t = key => {
    var _props$overrideString;

    return ((_props$overrideString = props.overrideStrings) == null ? void 0 : _props$overrideString[key]) || defaultStrings[key];
  };

  return React__default.createElement(MultiSelectContext.Provider, {
    value: {
      t,
      ...defaultProps,
      ...props
    }
  }, children);
};
const useMultiSelect = () => React__default.useContext(MultiSelectContext);

/**
 * similar to `useEffect` but gets triggered only when value changes
 * @param fn executable function on dependency updates
 * @param inputs dependency array
 */

function useDidUpdateEffect(fn, inputs) {
  const didMountRef = React.useRef(false);
  React.useEffect(() => {
    if (didMountRef.current) fn();else didMountRef.current = true;
  }, inputs);
}

/*
 * copied from https://github.com/imbhargav5/rooks/blob/master/packages/shared/useKeyRef.ts
 */
const defaultOptions = {
  when: true,
  eventTypes: ["keydown"]
};
/**
 * useKey hook
 *
 * Fires a callback on keyboard events like keyDown, keyPress and keyUp
 *
 * @param {[string|number]} keyList
 * @param {function} callback
 * @param {Options} options
 */

function useKey(input, callback, opts) {
  const keyList = React.useMemo(() => Array.isArray(input) ? input : [input], [input]);
  const options = Object.assign({}, defaultOptions, opts);
  const {
    when,
    eventTypes
  } = options;
  const callbackRef = React.useRef(callback);
  let {
    target
  } = options;
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  const handle = React.useCallback(e => {
    if (keyList.some(k => e.key === k || e.code === k)) {
      callbackRef.current(e);
    }
  }, [keyList]);
  React.useEffect(() => {
    if (when && typeof window !== "undefined") {
      const targetNode = target ? target["current"] : window;
      eventTypes.forEach(eventType => {
        targetNode && targetNode.addEventListener(eventType, handle);
      });
      return () => {
        eventTypes.forEach(eventType => {
          targetNode && targetNode.removeEventListener(eventType, handle);
        });
      };
    }
  }, [when, eventTypes, keyList, target, callback]);
}

const KEY = {
  ARROW_DOWN: "ArrowDown",
  ARROW_UP: "ArrowUp",
  ENTER: "Enter",
  ESCAPE: "Escape",
  SPACE: "Space"
};

const debounce = (func, wait) => {
  let timeout;
  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(null, args);
    }, wait);
  };
};

/**
 * Filters React Select options and sorts by similarity to a search filter.
 * Handles partial matches, eg. searching for "Waberg High" will find "Raoul
 * Wallenberg Traditional High School". Case insensitive. Ignores
 * non-alphanumeric characters.
 *
 * @param  options  An unfiltered list of Options.
 * @param? filter  A string to compare against Option labels.
 * @param? substitutions  Strings with multiple spellings or variations that we
 *           expect to match, eg. accented characters or abbreviated words.
 *
 * @return A filtered and sorted array of Options.
 */
function filterOptions(options, filter, substitutions) {
  // If the filter is blank, return the full list of Options.
  if (!filter) {
    return options;
  }

  const cleanFilter = cleanUpText(filter, substitutions);
  return options // Filter out undefined or null Options.
  .filter(({
    label,
    value
  }) => label != null && value != null) // Create a {score, Option} pair for each Option based on its label's
  // similarity to the filter text.
  .map(option => ({
    option: option,
    score: typeaheadSimilarity(cleanUpText(option.label, substitutions), cleanFilter)
  })) // Only include matches of the entire substring, with a slight
  // affordance for transposition or extra characters.
  .filter(pair => pair.score >= cleanFilter.length - 2) // Sort 'em by order of their score.
  .sort((a, b) => b.score - a.score) // …and grab the original Options back from their pairs.
  .map(pair => pair.option);
}
/**
 * Scores the similarity between two strings by returning the length of the
 * longest common subsequence. Intended for comparing strings of different
 * lengths; eg. when matching a typeahead search input with a school name.

 * Meant for use in an instant search box where results are being fetched
 * as a user is typing.
 *
 * @param  a  The longer string (though, we flip them if it's shorter).
 * @param  b  The shorter string, eg. a typeahead search input.
 *
 * @return The length of the longest common subsequence. Higher scores indicate
 *           closer matches.
 */

function typeaheadSimilarity(a, b) {
  const aLength = a.length;
  const bLength = b.length;
  const table = [];

  if (!aLength || !bLength) {
    return 0;
  } // Ensure `a` isn't shorter than `b`.


  if (aLength < bLength) {
    [a, b] = [b, a];
  } // Early exit if `a` includes `b`; these will be scored higher than any
  // other options with the same `b` (filter string), with a preference for
  // shorter `a` strings (option labels).


  if (a.indexOf(b) !== -1) {
    return bLength + 1 / aLength;
  } // Initialize the table axes:
  //
  //    0 0 0 0 ... bLength
  //    0
  //    0
  //
  //   ...
  //
  // aLength
  //


  for (let x = 0; x <= aLength; ++x) {
    table[x] = [0];
  }

  for (let y = 0; y <= bLength; ++y) {
    table[0][y] = 0;
  } // Populate the rest of the table with a dynamic programming algorithm.


  for (let x = 1; x <= aLength; ++x) {
    for (let y = 1; y <= bLength; ++y) {
      table[x][y] = a[x - 1] === b[y - 1] ? 1 + table[x - 1][y - 1] : Math.max(table[x][y - 1], table[x - 1][y]);
    }
  }

  return table[aLength][bLength];
}
/**
 * Apply string substitutions, remove non-alphanumeric characters, and convert
 * all letters to uppercase.
 *
 * eg. 'Scoil Bhríde Primary School' may become 'SCOILBHRIDEPRIMARYSCHOOL'.
 *
 * @param  input  An unsanitized input string.
 * @param  substitutions  Strings with multiple spellings or variations that we
 *          expect to match, for example accented characters or abbreviated
 *          words.
 *
 * @return The sanitized text.
 */

function cleanUpText(input, substitutions) {
  if (!input) {
    return "";
  } // Uppercase and remove all non-alphanumeric, non-accented characters.
  // Also remove underscores.


  input = input.toUpperCase().replace(/((?=[^\u00E0-\u00FC])\W)|_/g, "");

  if (!substitutions) {
    return input;
  }

  const safeSubstitutions = substitutions; // For Flow.
  // Replace all strings in `safeSubstitutions` with their standardized
  // counterparts.

  return Object.keys(safeSubstitutions).reduce((output, substitution) => {
    const unsubbed = new RegExp(substitution, "g");
    return output.replace(unsubbed, safeSubstitutions[substitution]);
  }, input);
}

const Cross = () => React__default.createElement("svg", {
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  className: "dropdown-search-clear-icon gray"
}, React__default.createElement("line", {
  x1: "18",
  y1: "6",
  x2: "6",
  y2: "18"
}), React__default.createElement("line", {
  x1: "6",
  y1: "6",
  x2: "18",
  y2: "18"
}));

const DefaultItemRenderer = ({
  checked,
  option,
  onClick,
  disabled
}) => React__default.createElement("div", {
  className: "item-renderer " + (disabled && "disabled")
}, React__default.createElement("input", {
  type: "checkbox",
  onChange: onClick,
  checked: checked,
  tabIndex: -1,
  disabled: disabled
}), React__default.createElement("span", null, option.label));

/**
 * This component represents an individual item in the multi-select drop-down
 */

const SelectItem = ({
  itemRenderer: ItemRenderer = DefaultItemRenderer,
  option,
  checked,
  tabIndex,
  disabled,
  onSelectionChanged,
  onClick
}) => {
  const itemRef = React.useRef();

  const onOptionCheck = e => {
    toggleChecked();
    e.preventDefault();
  };

  const toggleChecked = () => {
    if (!disabled) {
      onSelectionChanged(!checked);
    }
  };

  const handleClick = e => {
    toggleChecked();
    onClick(e);
  };

  useKey([KEY.ENTER, KEY.SPACE], onOptionCheck, {
    target: itemRef
  });
  return React__default.createElement("label", {
    className: "select-item " + (checked && "selected"),
    role: "option",
    "aria-selected": checked,
    tabIndex: tabIndex,
    ref: itemRef
  }, React__default.createElement(ItemRenderer, {
    option: option,
    checked: checked,
    onClick: handleClick,
    disabled: disabled
  }));
};

/**
 * This component represents an unadorned list of SelectItem (s).
 */

const SelectList = ({
  options,
  onClick,
  skipIndex
}) => {
  const {
    disabled,
    value,
    onChange,
    ItemRenderer
  } = useMultiSelect();

  const handleSelectionChanged = (option, checked) => {
    if (disabled) return;
    onChange(checked ? [...value, option] : value.filter(o => o.value !== option.value));
  };

  return React__default.createElement(React__default.Fragment, null, options.map((o, i) => {
    const tabIndex = i + skipIndex;
    return React__default.createElement("li", {
      key: (o == null ? void 0 : o.key) || i
    }, React__default.createElement(SelectItem, {
      tabIndex: tabIndex,
      option: o,
      onSelectionChanged: c => handleSelectionChanged(o, c),
      checked: !!value.find(s => s.value === o.value),
      onClick: e => onClick(e, tabIndex),
      itemRenderer: ItemRenderer,
      disabled: o.disabled || disabled
    }));
  }));
};

/**
 * This component represents the entire panel which gets dropped down when the
 * user selects the component.  It encapsulates the search filter, the
 * Select-all item, and the list of options.
 */
var FocusType;

(function (FocusType) {
  FocusType[FocusType["SEARCH"] = 0] = "SEARCH";
  FocusType[FocusType["NONE"] = -1] = "NONE";
})(FocusType || (FocusType = {}));

const SelectPanel = () => {
  const {
    t,
    onChange,
    options,
    value,
    filterOptions: customFilterOptions,
    selectAllLabel,
    ItemRenderer,
    disabled,
    disableSearch,
    hasSelectAll,
    ClearIcon,
    debounceDuration
  } = useMultiSelect();
  const listRef = React.useRef();
  const searchInputRef = React.useRef();
  const [searchText, setSearchText] = React.useState("");
  const [filteredOptions, setFilteredOptions] = React.useState(options);
  const [searchTextForFilter, setSearchTextForFilter] = React.useState("");
  const [focusIndex, setFocusIndex] = React.useState(0);
  const debouncedSearch = React.useCallback(debounce(query => setSearchTextForFilter(query), debounceDuration), []);
  const skipIndex = React.useMemo(() => {
    let start = 0;
    if (!disableSearch) start += 1; // if search is enabled then +1 to skipIndex

    if (hasSelectAll) start += 1; // if select-all is enabled then +1 to skipIndex

    return start;
  }, [disableSearch, hasSelectAll]);
  const selectAllOption = {
    label: selectAllLabel || t("selectAll"),
    value: ""
  };

  const selectAllValues = checked => {
    const filteredValues = filteredOptions.filter(o => !o.disabled).map(o => o.value);

    if (checked) {
      const selectedValues = value.map(o => o.value);
      const finalSelectedValues = [...selectedValues, ...filteredValues];
      return filteredOptions.filter(o => finalSelectedValues.includes(o.value));
    }

    return value.filter(o => !filteredValues.includes(o.value));
  };

  const selectAllChanged = checked => {
    const newOptions = selectAllValues(checked);
    onChange(newOptions);
  };

  const handleSearchChange = e => {
    debouncedSearch(e.target.value);
    setSearchText(e.target.value);
    setFocusIndex(FocusType.SEARCH);
  };

  const handleClear = () => {
    var _searchInputRef$curre;

    setSearchTextForFilter("");
    setSearchText("");
    searchInputRef == null ? void 0 : (_searchInputRef$curre = searchInputRef.current) == null ? void 0 : _searchInputRef$curre.focus();
  };

  const handleItemClicked = index => setFocusIndex(index); // Arrow Key Navigation


  const handleKeyDown = e => {
    switch (e.code) {
      case KEY.ARROW_UP:
        updateFocus(-1);
        break;

      case KEY.ARROW_DOWN:
        updateFocus(1);
        break;

      default:
        return;
    }

    e.stopPropagation();
    e.preventDefault();
  };

  useKey([KEY.ARROW_DOWN, KEY.ARROW_UP], handleKeyDown, {
    target: listRef
  });

  const handleSearchFocus = () => {
    setFocusIndex(FocusType.SEARCH);
  };

  const getFilteredOptions = async () => customFilterOptions ? await customFilterOptions(options, searchTextForFilter) : filterOptions(options, searchTextForFilter);

  const updateFocus = offset => {
    let newFocus = focusIndex + offset;
    newFocus = Math.max(0, newFocus);
    newFocus = Math.min(newFocus, options.length + Math.max(skipIndex - 1, 0));
    setFocusIndex(newFocus);
  };

  React.useEffect(() => {
    var _listRef$current, _listRef$current$quer;

    listRef == null ? void 0 : (_listRef$current = listRef.current) == null ? void 0 : (_listRef$current$quer = _listRef$current.querySelector("[tabIndex='" + focusIndex + "']")) == null ? void 0 : _listRef$current$quer.focus();
  }, [focusIndex]);
  const [isAllOptionSelected, hasSelectableOptions] = React.useMemo(() => {
    const filteredOptionsList = filteredOptions.filter(o => !o.disabled);
    return [filteredOptionsList.every(o => value.findIndex(v => v.value === o.value) !== -1), filteredOptionsList.length !== 0]; // eslint-disable-next-line
  }, [filteredOptions, value]);
  React.useEffect(() => {
    getFilteredOptions().then(setFilteredOptions);
  }, [searchTextForFilter, options]);
  return React__default.createElement("div", {
    className: "select-panel",
    role: "listbox",
    ref: listRef
  }, !disableSearch && React__default.createElement("div", {
    className: "search"
  }, React__default.createElement("input", {
    placeholder: t("search"),
    type: "text",
    "aria-describedby": t("search"),
    onChange: handleSearchChange,
    onFocus: handleSearchFocus,
    value: searchText,
    ref: searchInputRef,
    tabIndex: 0
  }), React__default.createElement("button", {
    type: "button",
    className: "search-clear-button",
    hidden: !searchText,
    onClick: handleClear,
    "aria-label": t("clearSearch")
  }, ClearIcon || React__default.createElement(Cross, null))), React__default.createElement("ul", {
    className: "options"
  }, hasSelectAll && hasSelectableOptions && React__default.createElement(SelectItem, {
    tabIndex: skipIndex === 1 ? 0 : 1,
    checked: isAllOptionSelected,
    option: selectAllOption,
    onSelectionChanged: selectAllChanged,
    onClick: () => handleItemClicked(1),
    itemRenderer: ItemRenderer,
    disabled: disabled
  }), filteredOptions.length ? React__default.createElement(SelectList, {
    skipIndex: skipIndex,
    options: filteredOptions,
    onClick: (_e, index) => handleItemClicked(index)
  }) : React__default.createElement("li", {
    className: "no-options"
  }, t("noOptions"))));
};

const Arrow = ({
  expanded
}) => React__default.createElement("svg", {
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  className: "dropdown-heading-dropdown-arrow gray"
}, React__default.createElement("path", {
  d: expanded ? "M18 15 12 9 6 15" : "M6 9L12 15 18 9"
}));

const DropdownHeader = () => {
  const {
    t,
    value,
    options,
    valueRenderer
  } = useMultiSelect();
  const noneSelected = value.length === 0;
  const allSelected = value.length === options.length;
  const customText = valueRenderer && valueRenderer(value, options);

  const getSelectedText = () => value.map(s => s.label).join(", ");

  return noneSelected ? React__default.createElement("span", {
    className: "gray"
  }, customText || t("selectSomeItems")) : React__default.createElement("span", null, customText || (allSelected ? t("allItemsAreSelected") : getSelectedText()));
};

const Loading = ({
  size = 24
}) => React__default.createElement("span", {
  style: {
    width: size,
    marginRight: "0.2rem"
  }
}, React__default.createElement("svg", {
  width: size,
  height: size,
  className: "spinner",
  viewBox: "0 0 50 50",
  style: {
    display: "inline",
    verticalAlign: "middle"
  }
}, React__default.createElement("circle", {
  cx: "25",
  cy: "25",
  r: "20",
  fill: "none",
  className: "path"
})));

/**
 * A generic dropdown component.  It takes the children of the component
 * and hosts it in the component.  When the component is selected, it
 * drops-down the contentComponent and applies the contentProps.
 */

const Dropdown = () => {
  const {
    t,
    onMenuToggle,
    ArrowRenderer,
    shouldToggleOnHover,
    isLoading,
    disabled,
    onChange,
    labelledBy,
    value,
    isOpen,
    defaultIsOpen,
    ClearSelectedIcon
  } = useMultiSelect();
  const [isInternalExpand, setIsInternalExpand] = React.useState(true);
  const [expanded, setExpanded] = React.useState(defaultIsOpen);
  const [hasFocus, setHasFocus] = React.useState(false);
  const FinalArrow = ArrowRenderer || Arrow;
  const wrapper = React.useRef();
  useDidUpdateEffect(() => {
    onMenuToggle && onMenuToggle(expanded);
  }, [expanded]);
  React.useEffect(() => {
    if (defaultIsOpen === undefined && typeof isOpen === "boolean") {
      setIsInternalExpand(false);
      setExpanded(isOpen);
    }
  }, [isOpen]);

  const handleKeyDown = e => {
    // allows space when focused on input
    if (e.target.type === "text" && e.code === KEY.SPACE) {
      return;
    }

    if (isInternalExpand) {
      if (e.code === KEY.ESCAPE) {
        var _wrapper$current;

        setExpanded(false);
        wrapper == null ? void 0 : (_wrapper$current = wrapper.current) == null ? void 0 : _wrapper$current.focus();
      } else {
        setExpanded(true);
      }
    }

    e.preventDefault();
  };

  useKey([KEY.ENTER, KEY.ARROW_DOWN, KEY.SPACE, KEY.ESCAPE], handleKeyDown, {
    target: wrapper
  });

  const handleHover = iexpanded => {
    isInternalExpand && shouldToggleOnHover && setExpanded(iexpanded);
  };

  const handleFocus = () => !hasFocus && setHasFocus(true);

  const handleBlur = e => {
    if (!e.currentTarget.contains(e.relatedTarget) && isInternalExpand) {
      setHasFocus(false);
      setExpanded(false);
    }
  };

  const handleMouseEnter = () => handleHover(true);

  const handleMouseLeave = () => handleHover(false);

  const toggleExpanded = () => {
    isInternalExpand && setExpanded(isLoading || disabled ? false : !expanded);
  };

  const handleClearSelected = e => {
    e.stopPropagation();
    onChange([]);
    isInternalExpand && setExpanded(false);
  };

  return React__default.createElement("div", {
    tabIndex: 0,
    className: "dropdown-container",
    "aria-labelledby": labelledBy,
    "aria-expanded": expanded,
    "aria-readonly": true,
    "aria-disabled": disabled,
    ref: wrapper,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }, React__default.createElement("div", {
    className: "dropdown-heading",
    onClick: toggleExpanded
  }, React__default.createElement("div", {
    className: "dropdown-heading-value"
  }, React__default.createElement(DropdownHeader, null)), isLoading && React__default.createElement(Loading, null), value.length > 0 && React__default.createElement("button", {
    type: "button",
    className: "clear-selected-button",
    onClick: handleClearSelected,
    disabled: disabled,
    "aria-label": t("clearSelected")
  }, ClearSelectedIcon || React__default.createElement(Cross, null)), React__default.createElement(FinalArrow, {
    expanded: expanded
  })), expanded && React__default.createElement("div", {
    className: "dropdown-content"
  }, React__default.createElement("div", {
    className: "panel-content"
  }, React__default.createElement(SelectPanel, null))));
};

const MultiSelect = props => React__default.createElement(MultiSelectProvider, {
  props: props
}, React__default.createElement("div", {
  className: "rmsc " + (props.className || "multi-select")
}, React__default.createElement(Dropdown, null)));

exports.Dropdown = Dropdown;
exports.SelectItem = SelectItem;
exports.SelectPanel = SelectPanel;
exports.default = MultiSelect;
//# sourceMappingURL=react-multi-select-component.cjs.development.js.map
