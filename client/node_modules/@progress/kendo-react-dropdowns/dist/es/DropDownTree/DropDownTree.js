var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { classNames, noop, useRtl, getTabIndex, Keys, mapTree, extendDataItem, guid } from '@progress/kendo-react-common';
import { Popup } from '@progress/kendo-react-popup';
import { useLocalization } from '@progress/kendo-react-intl';
import { TreeView } from '@progress/kendo-react-treeview';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from './../package-metadata';
import { getItemValue, areSame, isPresent } from '../common/utils';
import { useDropdownWidth } from './useDropdownWidth';
import { ListNoData } from './ListNoData';
import { messages, clear, nodata } from './../messages';
import { FloatingLabel } from '@progress/kendo-react-labels';
var VALIDATION_MESSAGE = 'Please select a value from the list!';
var ValueHolder = function (props) { return React.createElement(React.Fragment, null, props.children); };
var toLevel = function (hierarchicalIndex) {
    return hierarchicalIndex.split('_').map(function (i) { return parseInt(i, 10); });
};
var getValidity = function (_a, hasValue) {
    var validationMessage = _a.validationMessage, valid = _a.valid, required = _a.required;
    return ({
        customError: validationMessage !== undefined,
        valid: Boolean(valid !== undefined ? valid : (!required || hasValue)),
        valueMissing: !hasValue
    });
};
var defaultProps = {
    selectField: 'selected',
    popupSettings: {
        animate: true,
        width: '200px',
        height: '200px'
    },
    required: false,
    validityStyles: true
};
/**
 * Represents the DropDownTree component.
 */
export var DropDownTree = React.forwardRef(function (props, ref) {
    validatePackage(packageMetadata);
    var calculatedId = React.useMemo(function () { return guid(); }, []);
    var id = props.id || calculatedId;
    var _a = props.data, data = _a === void 0 ? [] : _a, dataItemKey = props.dataItemKey, _b = props.popupSettings, popupSettings = _b === void 0 ? {} : _b, _c = props.style, style = _c === void 0 ? {} : _c, opened = props.opened, disabled = props.disabled, _d = props.onOpen, onOpen = _d === void 0 ? noop : _d, _e = props.onClose, onClose = _e === void 0 ? noop : _e, placeholder = props.placeholder, label = props.label, name = props.name, _f = props.selectField, selectField = _f === void 0 ? defaultProps.selectField : _f, validationMessage = props.validationMessage, valid = props.valid, _g = props.required, required = _g === void 0 ? defaultProps.required : _g, _h = props.validityStyles, validityStyles = _h === void 0 ? defaultProps.validityStyles : _h;
    var tabIndex = getTabIndex(props.tabIndex, disabled);
    var target = React.useRef(null);
    var elementRef = React.useRef(null);
    var inputRef = React.useRef(null);
    var selectRef = React.useRef(null);
    var treeViewRef = React.useRef(null);
    var skipFocusRef = React.useRef(false);
    var _j = React.useState(undefined), stateValue = _j[0], setStateValue = _j[1];
    var controlled = props.value !== undefined;
    var value = controlled ? props.value : (stateValue !== undefined ? stateValue : props.defaultValue);
    var hasValue = isPresent(value);
    var currentValueText = hasValue ? getItemValue(value, props.textField) : '';
    var validity = getValidity({ validationMessage: validationMessage, valid: valid, required: required }, hasValue);
    var focus = React.useCallback(function () { return elementRef.current && elementRef.current.focus(); }, []);
    React.useImperativeHandle(target, function () { return ({
        props: props,
        element: elementRef.current,
        actionElement: elementRef.current,
        focus: focus
    }); });
    React.useImperativeHandle(ref, function () { return target.current; });
    var dir = useRtl(elementRef, props.dir);
    var initialStyleWidth = popupSettings.width !== undefined ?
        popupSettings.width : (style.width !== undefined ? style.width : defaultProps.popupSettings.width);
    var popupWidth = useDropdownWidth(elementRef, initialStyleWidth);
    var popupStyles = __assign({ width: popupWidth }, (dir !== undefined ? { direction: dir } : {}));
    var _k = React.useState(false), open = _k[0], setOpen = _k[1];
    var isOpen = opened !== undefined ? opened : open;
    var _l = React.useState(false), focused = _l[0], setFocused = _l[1];
    var _m = React.useState(''), filter = _m[0], setFilter = _m[1];
    var setValidity = React.useCallback(function () {
        if (selectRef.current && selectRef.current.setCustomValidity) {
            selectRef.current.setCustomValidity(validity.valid
                ? ''
                : validationMessage === undefined ? VALIDATION_MESSAGE : validationMessage);
        }
    }, [validationMessage, validity]);
    React.useEffect(setValidity);
    var openPopup = React.useCallback(function (event) {
        if (!isOpen) {
            if (onOpen) {
                var openEvent = __assign({}, event);
                onOpen.call(undefined, openEvent);
            }
            if (opened === undefined) {
                setOpen(true);
            }
        }
    }, [isOpen, opened, onOpen]);
    var closePopup = React.useCallback(function (event) {
        if (isOpen) {
            if (onClose) {
                var closeEvent = __assign({}, event);
                onClose.call(undefined, closeEvent);
            }
            if (opened === undefined) {
                setOpen(false);
            }
        }
    }, [isOpen, opened, onClose]);
    var onWrapperClick = React.useCallback(function (event) {
        if (!event.isDefaultPrevented() && target.current) {
            setFocused(true);
            var ev = {
                syntheticEvent: event,
                nativeEvent: event.nativeEvent,
                target: target.current
            };
            (isOpen ? closePopup : openPopup)(ev);
        }
    }, [isOpen, opened, onOpen, onClose]);
    var switchFocus = React.useCallback(function (focusFn) {
        skipFocusRef.current = true;
        focusFn();
        window.setTimeout(function () { return skipFocusRef.current = false; }, 0);
    }, []);
    var onWrapperKeyDown = React.useCallback(function (event) {
        var keyCode = event.keyCode, altKey = event.altKey;
        var treeview = treeViewRef.current && treeViewRef.current.element;
        if (!target.current || (event.isDefaultPrevented() && inputRef.current === event.target)) {
            return;
        }
        var ev = {
            syntheticEvent: event,
            nativeEvent: event.nativeEvent,
            target: target.current
        };
        if (isOpen) {
            if (keyCode === Keys.esc || (altKey && keyCode === Keys.up)) {
                closePopup(ev);
            }
            else if (treeview && treeview.querySelector('.k-state-focused') &&
                (keyCode === Keys.up || keyCode === Keys.down ||
                    keyCode === Keys.left || keyCode === Keys.right ||
                    keyCode === Keys.home || keyCode === Keys.end)) {
                if (keyCode === Keys.up && inputRef.current) {
                    var items = Array.from(treeview.querySelectorAll('.k-treeview-item'));
                    var focusedItem = items.slice().reverse().find(function (i) { return Boolean(i && i.querySelector('.k-state-focused')); });
                    if (focusedItem && items.indexOf(focusedItem) === 0) {
                        return switchFocus(function () { focusElement(inputRef.current); });
                    }
                }
                switchFocus(noop);
            }
            else if (keyCode === Keys.down) {
                switchFocus(function () { focusElement(inputRef.current || treeview); });
            }
        }
        else {
            if (altKey && keyCode === Keys.down) {
                openPopup(ev);
            }
        }
    }, [isOpen, opened, onOpen, onClose]);
    var onInputKeyDown = React.useCallback(function (event) {
        var keyCode = event.keyCode, altKey = event.altKey;
        if (altKey || (keyCode !== Keys.up && keyCode !== Keys.down)) {
            return;
        }
        event.preventDefault();
        switchFocus(keyCode === Keys.up ?
            function () { focusElement(elementRef.current); } :
            function () { focusElement(treeViewRef.current && treeViewRef.current.element); });
    }, []);
    var focusElement = React.useCallback(function (element) {
        if (element) {
            switchFocus(function () { return element.focus(); });
        }
    }, []);
    var onPopupOpened = React.useCallback(function () {
        if (!focused && isOpen) {
            closePopup({ target: target.current });
        }
        else {
            if (props.filterable) {
                focusElement(inputRef.current);
            }
            else {
                focusElement(treeViewRef.current && treeViewRef.current.element);
            }
        }
    }, [onClose, props.filterable, focused, opened, isOpen]);
    var onPopupClosed = React.useCallback(function () {
        if (focused) {
            // Move the focus from treeview to dropdown without triggering Focus or Blur events.
            focusElement(elementRef.current);
        }
    }, [focused]);
    var onFocus = React.useCallback(function (event) {
        if (!focused && !skipFocusRef.current) {
            setFocused(true);
            if (props.onFocus && target.current) {
                var focusEvent = {
                    syntheticEvent: event,
                    nativeEvent: event.nativeEvent,
                    target: target.current
                };
                props.onFocus.call(undefined, focusEvent);
            }
        }
    }, [focused, props.onFocus]);
    var onBlur = React.useCallback(function (event) {
        if (focused && !skipFocusRef.current && target.current) {
            setFocused(false);
            var ev = {
                syntheticEvent: event,
                nativeEvent: event.nativeEvent,
                target: target.current
            };
            if (props.onBlur) {
                var focusEvent = __assign({}, ev);
                props.onBlur.call(undefined, focusEvent);
            }
            closePopup(ev);
        }
    }, [focused, props.onBlur, isOpen, opened, onClose]);
    var onWrapperMouseDown = React.useCallback(function () {
        if (focused) {
            // moving focus from treeview to dropdown triggers Focus and Blur events.
            switchFocus(noop);
        }
    }, [focused]);
    var changeValue = React.useCallback(function (event, newValue, hierarchicalIndex) {
        if (props.onChange) {
            var changeEvent = __assign({ value: newValue, level: hierarchicalIndex ? toLevel(hierarchicalIndex) : [] }, event);
            props.onChange.call(undefined, changeEvent);
        }
        if (!controlled) {
            setStateValue(newValue);
        }
    }, [props.onChange, controlled]);
    var onChange = React.useCallback(function (event) {
        if (areSame(event.item, value, dataItemKey) || !target.current) {
            return;
        }
        var item = event.item, itemHierarchicalIndex = event.itemHierarchicalIndex, nativeEvent = event.nativeEvent, syntheticEvent = event.syntheticEvent;
        var ev = {
            syntheticEvent: syntheticEvent,
            nativeEvent: nativeEvent,
            target: target.current
        };
        changeValue(ev, item, itemHierarchicalIndex);
        closePopup(ev);
    }, [controlled, value, props.onChange, dataItemKey, isOpen, opened, onClose]);
    var onClear = React.useCallback(function (event) {
        if (!target.current) {
            return;
        }
        var ev = {
            syntheticEvent: event,
            nativeEvent: event.nativeEvent,
            target: target.current
        };
        changeValue(ev, null);
        closePopup(ev);
        event.preventDefault();
    }, [controlled, props.onChange, isOpen, opened, onClose]);
    var onExpand = React.useCallback(function (event) {
        if (props.onExpandChange && target.current) {
            var item = event.item, itemHierarchicalIndex = event.itemHierarchicalIndex, nativeEvent = event.nativeEvent, syntheticEvent = event.syntheticEvent;
            var expandEvent = {
                level: toLevel(itemHierarchicalIndex),
                item: item, nativeEvent: nativeEvent, syntheticEvent: syntheticEvent, target: target.current
            };
            props.onExpandChange.call(undefined, expandEvent);
        }
    }, [props.onExpandChange]);
    var onFilterChange = React.useCallback(function (event) {
        if (props.onFilterChange && target.current) {
            var filterDesc = { field: props.textField, operator: 'contains', value: event.target.value };
            var ev = {
                filter: filterDesc,
                syntheticEvent: event,
                nativeEvent: event.nativeEvent,
                target: target.current
            };
            props.onFilterChange.call(undefined, ev);
            if (props.filter === undefined) {
                setFilter(event.target.value);
            }
        }
    }, [props.onFilterChange, props.filter, props.textField]);
    var treeViewData = React.useMemo(function () {
        return (controlled || !hasValue) ? data :
            mapTree(data, 'items', function (item) {
                var _a;
                return extendDataItem(item, 'items', (_a = {}, _a[selectField] = areSame(item, value, dataItemKey), _a));
            });
    }, [data, value, controlled, hasValue, selectField]);
    var NoData = props.listNoData || ListNoData;
    var ValueComponent = props.valueHolder || ValueHolder;
    var localization = useLocalization();
    var isValid = !validityStyles || validity.valid;
    var dropdowntree = (React.createElement("span", { className: classNames('k-widget k-dropdowntree k-dropdowntree-clearable', props.className), tabIndex: tabIndex, accessKey: props.accessKey, id: id, style: label ? __assign({}, style, { width: undefined }) : style, dir: dir, ref: elementRef, onKeyDown: disabled ? undefined : onWrapperKeyDown, onMouseDown: onWrapperMouseDown, onFocus: onFocus, onBlur: onBlur, role: "listbox", "aria-haspopup": "true", "aria-expanded": isOpen, "aria-disabled": disabled, "aria-label": label, "aria-labelledby": props.ariaLabelledBy, "aria-describedby": props.ariaDescribedBy },
        React.createElement("span", { className: classNames('k-dropdown-wrap k-state-default', {
                'k-state-focused': focused,
                'k-state-disabled': disabled,
                'k-state-invalid': !isValid
            }), onClick: disabled ? undefined : onWrapperClick },
            React.createElement("span", { className: "k-input" },
                React.createElement(ValueComponent, { item: value }, currentValueText || placeholder)),
            hasValue && !disabled && (React.createElement("span", { onClick: onClear, className: "k-icon k-clear-value k-i-close", title: localization.toLanguageString(clear, messages[clear]), role: "button", tabIndex: -1, onMouseDown: function (e) { return e.preventDefault(); } })),
            React.createElement("span", { className: "k-select", "aria-label": "select" },
                React.createElement("span", { className: classNames('k-icon', { 'k-i-arrow-60-down': !props.loading, 'k-i-loading': props.loading }) })),
            React.createElement("select", { name: name, ref: selectRef, tabIndex: -1, "aria-hidden": true, title: label, style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: 'absolute', left: '50%' } },
                React.createElement("option", { value: props.valueMap ? props.valueMap.call(undefined, value) : value }))),
        React.createElement(Popup, { className: classNames('k-list-container k-group k-reset k-popup-dropdowntree', popupSettings.className, { 'k-rtl': dir === 'rtl' }), style: popupStyles, animate: popupSettings.animate, anchor: elementRef.current, show: isOpen, onOpen: onPopupOpened, onClose: onPopupClosed, appendTo: popupSettings.appendTo },
            props.filterable && (React.createElement("span", { className: "k-list-filter" },
                React.createElement("input", { className: "k-textbox", tabIndex: tabIndex, ref: inputRef, value: props.filter === undefined ? filter : props.filter, onChange: onFilterChange, onKeyDown: onInputKeyDown }),
                React.createElement("span", { className: "k-icon k-i-zoom" }))),
            data.length > 0 ? (React.createElement(TreeView, { ref: treeViewRef, tabIndex: tabIndex, data: treeViewData, focusIdField: dataItemKey, textField: props.textField, selectField: selectField, expandField: props.expandField, expandIcons: true, onItemClick: onChange, onExpandChange: onExpand, item: props.item })) : (React.createElement(NoData, null, localization.toLanguageString(nodata, messages[nodata]))))));
    return label ? (React.createElement(FloatingLabel, { label: label, editorValue: currentValueText, editorPlaceholder: placeholder, editorValid: isValid, editorDisabled: disabled, editorId: id, style: { width: style ? style.width : undefined }, children: dropdowntree, dir: dir })) : dropdowntree;
});
var propTypes = {
    opened: PropTypes.bool,
    disabled: PropTypes.bool,
    dir: PropTypes.string,
    tabIndex: PropTypes.number,
    accessKey: PropTypes.string,
    data: PropTypes.array,
    value: PropTypes.any,
    valueMap: PropTypes.func,
    placeholder: PropTypes.string,
    dataItemKey: PropTypes.string.isRequired,
    textField: PropTypes.string.isRequired,
    selectField: PropTypes.string,
    expandField: PropTypes.string,
    className: PropTypes.string,
    style: PropTypes.object,
    label: PropTypes.string,
    validationMessage: PropTypes.string,
    validityStyles: PropTypes.bool,
    valid: PropTypes.bool,
    required: PropTypes.bool,
    name: PropTypes.string,
    id: PropTypes.string,
    ariaLabelledBy: PropTypes.string,
    ariaDescribedBy: PropTypes.string,
    filterable: PropTypes.bool,
    filter: PropTypes.string,
    loading: PropTypes.bool,
    popupSettings: PropTypes.shape({
        animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.shape({
                openDuration: PropTypes.number,
                closeDuration: PropTypes.number
            })]),
        className: PropTypes.string,
        appendTo: PropTypes.any,
        width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
        height: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
    }),
    onOpen: PropTypes.func,
    onClose: PropTypes.func,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func,
    onChange: PropTypes.func,
    onFilterChange: PropTypes.func,
    onExpandChange: PropTypes.func,
    item: PropTypes.func,
    valueHolder: PropTypes.func,
    listNoData: PropTypes.func
};
DropDownTree.displayName = 'KendoReactDropDownTree';
DropDownTree.propTypes = propTypes;
//# sourceMappingURL=DropDownTree.js.map