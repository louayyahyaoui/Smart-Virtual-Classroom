{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.intlDateTimeFormatSupportedLocale = intlDateTimeFormatSupportedLocale;\nexports.intlDateTimeFormatSupported = intlDateTimeFormatSupported;\n/**\r\n * Whether can use `Intl.DateTimeFormat` for these `locales`.\r\n * Returns the first suitable one.\r\n * @param  {(string|string[])} locales\r\n * @return {?string} The first locale that can be used.\r\n */\n\nfunction intlDateTimeFormatSupportedLocale(locales) {\n  /* istanbul ignore else */\n  if (intlDateTimeFormatSupported()) {\n    return Intl.DateTimeFormat.supportedLocalesOf(locales)[0];\n  }\n}\n/**\r\n * Whether can use `Intl.DateTimeFormat`.\r\n * @return {boolean}\r\n */\n\n\nfunction intlDateTimeFormatSupported() {\n  // Babel transforms `typeof` into some \"branches\"\n  // so istanbul will show this as \"branch not covered\".\n\n  /* istanbul ignore next */\n  var isIntlAvailable = (typeof Intl === 'undefined' ? 'undefined' : _typeof(Intl)) === 'object';\n  return isIntlAvailable && typeof Intl.DateTimeFormat === 'function';\n}","map":{"version":3,"sources":["../../source/helpers/locale.js"],"names":["intlDateTimeFormatSupportedLocale","intlDateTimeFormatSupported","Intl","isIntlAvailable"],"mappings":";;;;;;;;;;;;QAMgBA,iC,GAAAA,iC;QAWAC,2B,GAAAA,2B;AAjBhB;;;;;;;AAMO,SAAA,iCAAA,CAAA,OAAA,EAAoD;AAC1D;AACA,MAAIA,2BAAJ,EAAA,EAAmC;AAClC,WAAOC,IAAAA,CAAAA,cAAAA,CAAAA,kBAAAA,CAAAA,OAAAA,EAAP,CAAOA,CAAP;AACA;AACD;AAED;;;;;;AAIO,SAAA,2BAAA,GAAuC;AAC7C;AACA;;AACA;AACA,MAAMC,eAAAA,GAAkB,CAAA,OAAA,IAAA,KAAA,WAAA,GAAA,WAAA,GAAA,OAAA,CAAA,IAAA,CAAA,MAAxB,QAAA;AACA,SAAOA,eAAAA,IAAmB,OAAOD,IAAAA,CAAP,cAAA,KAA1B,UAAA;AACA","sourcesContent":["/**\r\n * Whether can use `Intl.DateTimeFormat` for these `locales`.\r\n * Returns the first suitable one.\r\n * @param  {(string|string[])} locales\r\n * @return {?string} The first locale that can be used.\r\n */\r\nexport function intlDateTimeFormatSupportedLocale(locales) {\r\n\t/* istanbul ignore else */\r\n\tif (intlDateTimeFormatSupported()) {\r\n\t\treturn Intl.DateTimeFormat.supportedLocalesOf(locales)[0]\r\n\t}\r\n}\r\n\r\n/**\r\n * Whether can use `Intl.DateTimeFormat`.\r\n * @return {boolean}\r\n */\r\nexport function intlDateTimeFormatSupported() {\r\n\t// Babel transforms `typeof` into some \"branches\"\r\n\t// so istanbul will show this as \"branch not covered\".\r\n\t/* istanbul ignore next */\r\n\tconst isIntlAvailable = typeof Intl === 'object'\r\n\treturn isIntlAvailable && typeof Intl.DateTimeFormat === 'function'\r\n}\r\n"]},"metadata":{},"sourceType":"script"}