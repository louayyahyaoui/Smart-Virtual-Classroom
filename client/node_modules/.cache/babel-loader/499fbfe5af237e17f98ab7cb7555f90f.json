{"ast":null,"code":"var timespan = require('./lib/timespan');\n\nvar PS_SUPPORTED = require('./lib/psSupported');\n\nvar jws = require('jws');\n\nvar includes = require('lodash.includes');\n\nvar isBoolean = require('lodash.isboolean');\n\nvar isInteger = require('lodash.isinteger');\n\nvar isNumber = require('lodash.isnumber');\n\nvar isPlainObject = require('lodash.isplainobject');\n\nvar isString = require('lodash.isstring');\n\nvar once = require('lodash.once');\n\nvar SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];\n\nif (PS_SUPPORTED) {\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nvar sign_options_schema = {\n  expiresIn: {\n    isValid: function (value) {\n      return isInteger(value) || isString(value) && value;\n    },\n    message: '\"expiresIn\" should be a number of seconds or string representing a timespan'\n  },\n  notBefore: {\n    isValid: function (value) {\n      return isInteger(value) || isString(value) && value;\n    },\n    message: '\"notBefore\" should be a number of seconds or string representing a timespan'\n  },\n  audience: {\n    isValid: function (value) {\n      return isString(value) || Array.isArray(value);\n    },\n    message: '\"audience\" must be a string or array'\n  },\n  algorithm: {\n    isValid: includes.bind(null, SUPPORTED_ALGS),\n    message: '\"algorithm\" must be a valid string enum value'\n  },\n  header: {\n    isValid: isPlainObject,\n    message: '\"header\" must be an object'\n  },\n  encoding: {\n    isValid: isString,\n    message: '\"encoding\" must be a string'\n  },\n  issuer: {\n    isValid: isString,\n    message: '\"issuer\" must be a string'\n  },\n  subject: {\n    isValid: isString,\n    message: '\"subject\" must be a string'\n  },\n  jwtid: {\n    isValid: isString,\n    message: '\"jwtid\" must be a string'\n  },\n  noTimestamp: {\n    isValid: isBoolean,\n    message: '\"noTimestamp\" must be a boolean'\n  },\n  keyid: {\n    isValid: isString,\n    message: '\"keyid\" must be a string'\n  },\n  mutatePayload: {\n    isValid: isBoolean,\n    message: '\"mutatePayload\" must be a boolean'\n  }\n};\nvar registered_claims_schema = {\n  iat: {\n    isValid: isNumber,\n    message: '\"iat\" should be a number of seconds'\n  },\n  exp: {\n    isValid: isNumber,\n    message: '\"exp\" should be a number of seconds'\n  },\n  nbf: {\n    isValid: isNumber,\n    message: '\"nbf\" should be a number of seconds'\n  }\n};\n\nfunction validate(schema, allowUnknown, object, parameterName) {\n  if (!isPlainObject(object)) {\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\n  }\n\n  Object.keys(object).forEach(function (key) {\n    var validator = schema[key];\n\n    if (!validator) {\n      if (!allowUnknown) {\n        throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\n      }\n\n      return;\n    }\n\n    if (!validator.isValid(object[key])) {\n      throw new Error(validator.message);\n    }\n  });\n}\n\nfunction validateOptions(options) {\n  return validate(sign_options_schema, false, options, 'options');\n}\n\nfunction validatePayload(payload) {\n  return validate(registered_claims_schema, true, payload, 'payload');\n}\n\nvar options_to_payload = {\n  'audience': 'aud',\n  'issuer': 'iss',\n  'subject': 'sub',\n  'jwtid': 'jti'\n};\nvar options_for_objects = ['expiresIn', 'notBefore', 'noTimestamp', 'audience', 'issuer', 'subject', 'jwtid'];\n\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else {\n    options = options || {};\n  }\n\n  var isObjectPayload = typeof payload === 'object' && !Buffer.isBuffer(payload);\n  var header = Object.assign({\n    alg: options.algorithm || 'HS256',\n    typ: isObjectPayload ? 'JWT' : undefined,\n    kid: options.keyid\n  }, options.header);\n\n  function failure(err) {\n    if (callback) {\n      return callback(err);\n    }\n\n    throw err;\n  }\n\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\n    return failure(new Error('secretOrPrivateKey must have a value'));\n  }\n\n  if (typeof payload === 'undefined') {\n    return failure(new Error('payload is required'));\n  } else if (isObjectPayload) {\n    try {\n      validatePayload(payload);\n    } catch (error) {\n      return failure(error);\n    }\n\n    if (!options.mutatePayload) {\n      payload = Object.assign({}, payload);\n    }\n  } else {\n    var invalid_options = options_for_objects.filter(function (opt) {\n      return typeof options[opt] !== 'undefined';\n    });\n\n    if (invalid_options.length > 0) {\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + typeof payload + ' payload'));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  }\n\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  }\n\n  try {\n    validateOptions(options);\n  } catch (error) {\n    return failure(error);\n  }\n\n  var timestamp = payload.iat || Math.floor(Date.now() / 1000);\n\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else if (isObjectPayload) {\n    payload.iat = timestamp;\n  }\n\n  if (typeof options.notBefore !== 'undefined') {\n    try {\n      payload.nbf = timespan(options.notBefore, timestamp);\n    } catch (err) {\n      return failure(err);\n    }\n\n    if (typeof payload.nbf === 'undefined') {\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\n    try {\n      payload.exp = timespan(options.expiresIn, timestamp);\n    } catch (err) {\n      return failure(err);\n    }\n\n    if (typeof payload.exp === 'undefined') {\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  Object.keys(options_to_payload).forEach(function (key) {\n    var claim = options_to_payload[key];\n\n    if (typeof options[key] !== 'undefined') {\n      if (typeof payload[claim] !== 'undefined') {\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\n      }\n\n      payload[claim] = options[key];\n    }\n  });\n  var encoding = options.encoding || 'utf8';\n\n  if (typeof callback === 'function') {\n    callback = callback && once(callback);\n    jws.createSign({\n      header: header,\n      privateKey: secretOrPrivateKey,\n      payload: payload,\n      encoding: encoding\n    }).once('error', callback).once('done', function (signature) {\n      callback(null, signature);\n    });\n  } else {\n    return jws.sign({\n      header: header,\n      payload: payload,\n      secret: secretOrPrivateKey,\n      encoding: encoding\n    });\n  }\n};","map":{"version":3,"sources":["C:/Smart-Virtual-Classroom/client/node_modules/jsonwebtoken/sign.js"],"names":["timespan","require","PS_SUPPORTED","jws","includes","isBoolean","isInteger","isNumber","isPlainObject","isString","once","SUPPORTED_ALGS","splice","sign_options_schema","expiresIn","isValid","value","message","notBefore","audience","Array","isArray","algorithm","bind","header","encoding","issuer","subject","jwtid","noTimestamp","keyid","mutatePayload","registered_claims_schema","iat","exp","nbf","validate","schema","allowUnknown","object","parameterName","Error","Object","keys","forEach","key","validator","validateOptions","options","validatePayload","payload","options_to_payload","options_for_objects","module","exports","secretOrPrivateKey","callback","isObjectPayload","Buffer","isBuffer","assign","alg","typ","undefined","kid","failure","err","error","invalid_options","filter","opt","length","join","timestamp","Math","floor","Date","now","claim","createSign","privateKey","signature","sign","secret"],"mappings":"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","sourcesContent":["var timespan = require('./lib/timespan');\nvar PS_SUPPORTED = require('./lib/psSupported');\nvar jws = require('jws');\nvar includes = require('lodash.includes');\nvar isBoolean = require('lodash.isboolean');\nvar isInteger = require('lodash.isinteger');\nvar isNumber = require('lodash.isnumber');\nvar isPlainObject = require('lodash.isplainobject');\nvar isString = require('lodash.isstring');\nvar once = require('lodash.once');\n\nvar SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none']\nif (PS_SUPPORTED) {\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nvar sign_options_schema = {\n  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"expiresIn\" should be a number of seconds or string representing a timespan' },\n  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"notBefore\" should be a number of seconds or string representing a timespan' },\n  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '\"audience\" must be a string or array' },\n  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '\"algorithm\" must be a valid string enum value' },\n  header: { isValid: isPlainObject, message: '\"header\" must be an object' },\n  encoding: { isValid: isString, message: '\"encoding\" must be a string' },\n  issuer: { isValid: isString, message: '\"issuer\" must be a string' },\n  subject: { isValid: isString, message: '\"subject\" must be a string' },\n  jwtid: { isValid: isString, message: '\"jwtid\" must be a string' },\n  noTimestamp: { isValid: isBoolean, message: '\"noTimestamp\" must be a boolean' },\n  keyid: { isValid: isString, message: '\"keyid\" must be a string' },\n  mutatePayload: { isValid: isBoolean, message: '\"mutatePayload\" must be a boolean' }\n};\n\nvar registered_claims_schema = {\n  iat: { isValid: isNumber, message: '\"iat\" should be a number of seconds' },\n  exp: { isValid: isNumber, message: '\"exp\" should be a number of seconds' },\n  nbf: { isValid: isNumber, message: '\"nbf\" should be a number of seconds' }\n};\n\nfunction validate(schema, allowUnknown, object, parameterName) {\n  if (!isPlainObject(object)) {\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\n  }\n  Object.keys(object)\n    .forEach(function(key) {\n      var validator = schema[key];\n      if (!validator) {\n        if (!allowUnknown) {\n          throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\n        }\n        return;\n      }\n      if (!validator.isValid(object[key])) {\n        throw new Error(validator.message);\n      }\n    });\n}\n\nfunction validateOptions(options) {\n  return validate(sign_options_schema, false, options, 'options');\n}\n\nfunction validatePayload(payload) {\n  return validate(registered_claims_schema, true, payload, 'payload');\n}\n\nvar options_to_payload = {\n  'audience': 'aud',\n  'issuer': 'iss',\n  'subject': 'sub',\n  'jwtid': 'jti'\n};\n\nvar options_for_objects = [\n  'expiresIn',\n  'notBefore',\n  'noTimestamp',\n  'audience',\n  'issuer',\n  'subject',\n  'jwtid',\n];\n\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else {\n    options = options || {};\n  }\n\n  var isObjectPayload = typeof payload === 'object' &&\n                        !Buffer.isBuffer(payload);\n\n  var header = Object.assign({\n    alg: options.algorithm || 'HS256',\n    typ: isObjectPayload ? 'JWT' : undefined,\n    kid: options.keyid\n  }, options.header);\n\n  function failure(err) {\n    if (callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\n    return failure(new Error('secretOrPrivateKey must have a value'));\n  }\n\n  if (typeof payload === 'undefined') {\n    return failure(new Error('payload is required'));\n  } else if (isObjectPayload) {\n    try {\n      validatePayload(payload);\n    }\n    catch (error) {\n      return failure(error);\n    }\n    if (!options.mutatePayload) {\n      payload = Object.assign({},payload);\n    }\n  } else {\n    var invalid_options = options_for_objects.filter(function (opt) {\n      return typeof options[opt] !== 'undefined';\n    });\n\n    if (invalid_options.length > 0) {\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  }\n\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  }\n\n  try {\n    validateOptions(options);\n  }\n  catch (error) {\n    return failure(error);\n  }\n\n  var timestamp = payload.iat || Math.floor(Date.now() / 1000);\n\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else if (isObjectPayload) {\n    payload.iat = timestamp;\n  }\n\n  if (typeof options.notBefore !== 'undefined') {\n    try {\n      payload.nbf = timespan(options.notBefore, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.nbf === 'undefined') {\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\n    try {\n      payload.exp = timespan(options.expiresIn, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.exp === 'undefined') {\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  Object.keys(options_to_payload).forEach(function (key) {\n    var claim = options_to_payload[key];\n    if (typeof options[key] !== 'undefined') {\n      if (typeof payload[claim] !== 'undefined') {\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\n      }\n      payload[claim] = options[key];\n    }\n  });\n\n  var encoding = options.encoding || 'utf8';\n\n  if (typeof callback === 'function') {\n    callback = callback && once(callback);\n\n    jws.createSign({\n      header: header,\n      privateKey: secretOrPrivateKey,\n      payload: payload,\n      encoding: encoding\n    }).once('error', callback)\n      .once('done', function (signature) {\n        callback(null, signature);\n      });\n  } else {\n    return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});\n  }\n};\n"]},"metadata":{},"sourceType":"script"}