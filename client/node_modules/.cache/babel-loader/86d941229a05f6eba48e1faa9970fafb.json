{"ast":null,"code":"/**\r\n * DevExtreme (localization/ldml/date.parser.js)\r\n * Version: 20.2.7\r\n * Build date: Thu Apr 22 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nexports.getParser = exports.getPatternSetters = exports.getRegExpInfo = void 0;\n\nvar _common = require(\"../../core/utils/common\");\n\nvar FORMAT_TYPES = {\n  3: \"abbreviated\",\n  4: \"wide\",\n  5: \"narrow\"\n};\n\nvar monthRegExpGenerator = function (count, dateParts) {\n  if (count > 2) {\n    return Object.keys(FORMAT_TYPES).map(function (count) {\n      return [\"format\", \"standalone\"].map(function (type) {\n        return dateParts.getMonthNames(FORMAT_TYPES[count], type).join(\"|\");\n      }).join(\"|\");\n    }).join(\"|\");\n  }\n\n  return \"0?[1-9]|1[012]\";\n};\n\nvar PATTERN_REGEXPS = {\n  y: function (count) {\n    return \"[0-9]+\";\n  },\n  M: monthRegExpGenerator,\n  L: monthRegExpGenerator,\n  Q: function (count, dateParts) {\n    if (count > 2) {\n      return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").join(\"|\");\n    }\n\n    return \"0?[1-4]\";\n  },\n  E: function (count, dateParts) {\n    return \"\\\\D*\";\n  },\n  a: function (count, dateParts) {\n    return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\").join(\"|\");\n  },\n  d: function (count) {\n    return \"0?[1-9]|[12][0-9]|3[01]\";\n  },\n  H: function (count) {\n    return \"0?[0-9]|1[0-9]|2[0-3]\";\n  },\n  h: function (count) {\n    return \"0?[1-9]|1[012]\";\n  },\n  m: function (count) {\n    return \"0?[0-9]|[1-5][0-9]\";\n  },\n  s: function (count) {\n    return \"0?[0-9]|[1-5][0-9]\";\n  },\n  S: function (count) {\n    return \"[0-9]{1,\" + count + \"}\";\n  },\n  w: function (count) {\n    return \"0?[0-9]|[1-5][0-9]\";\n  }\n};\nvar parseNumber = Number;\n\nvar caseInsensitiveIndexOf = function (array, value) {\n  return array.map(function (item) {\n    return item.toLowerCase();\n  }).indexOf(value.toLowerCase());\n};\n\nvar monthPatternParser = function (text, count, dateParts) {\n  if (count > 2) {\n    return [\"format\", \"standalone\"].map(function (type) {\n      return Object.keys(FORMAT_TYPES).map(function (count) {\n        var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);\n        return caseInsensitiveIndexOf(monthNames, text);\n      });\n    }).reduce(function (a, b) {\n      return a.concat(b);\n    }).filter(function (index) {\n      return index >= 0;\n    })[0];\n  }\n\n  return parseNumber(text) - 1;\n};\n\nvar PATTERN_PARSERS = {\n  y: function (text, count) {\n    var year = parseNumber(text);\n\n    if (2 === count) {\n      return year < 30 ? 2e3 + year : 1900 + year;\n    }\n\n    return year;\n  },\n  M: monthPatternParser,\n  L: monthPatternParser,\n  Q: function (text, count, dateParts) {\n    if (count > 2) {\n      return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").indexOf(text);\n    }\n\n    return parseNumber(text) - 1;\n  },\n  E: function (text, count, dateParts) {\n    var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\n    return caseInsensitiveIndexOf(dayNames, text);\n  },\n  a: function (text, count, dateParts) {\n    var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\n    return caseInsensitiveIndexOf(periodNames, text);\n  },\n  d: parseNumber,\n  H: parseNumber,\n  h: parseNumber,\n  m: parseNumber,\n  s: parseNumber,\n  S: function (text, count) {\n    count = Math.max(count, 3);\n    text = text.slice(0, 3);\n\n    while (count < 3) {\n      text += \"0\";\n      count++;\n    }\n\n    return parseNumber(text);\n  }\n};\nvar ORDERED_PATTERNS = [\"y\", \"M\", \"d\", \"h\", \"m\", \"s\", \"S\"];\nvar PATTERN_SETTERS = {\n  y: \"setFullYear\",\n  M: \"setMonth\",\n  L: \"setMonth\",\n  a: function (date, value, datePartValues) {\n    var hours = date.getHours();\n    var hourPartValue = datePartValues.h;\n\n    if (void 0 !== hourPartValue && hourPartValue !== hours) {\n      hours--;\n    }\n\n    if (!value && 12 === hours) {\n      hours = 0;\n    } else {\n      if (value && 12 !== hours) {\n        hours += 12;\n      }\n    }\n\n    date.setHours(hours);\n  },\n  d: \"setDate\",\n  H: \"setHours\",\n  h: \"setHours\",\n  m: \"setMinutes\",\n  s: \"setSeconds\",\n  S: \"setMilliseconds\"\n};\n\nvar getSameCharCount = function (text, index) {\n  var char = text[index];\n  var count = 0;\n\n  do {\n    index++;\n    count++;\n  } while (text[index] === char);\n\n  return count;\n};\n\nvar createPattern = function (char, count) {\n  var result = \"\";\n\n  for (var i = 0; i < count; i++) {\n    result += char;\n  }\n\n  return result;\n};\n\nvar getRegExpInfo = function (format, dateParts) {\n  var regexpText = \"\";\n  var stubText = \"\";\n  var isEscaping;\n  var patterns = [];\n\n  var addPreviousStub = function () {\n    if (stubText) {\n      patterns.push(\"'\" + stubText + \"'\");\n      regexpText += (0, _common.escapeRegExp)(stubText) + \")\";\n      stubText = \"\";\n    }\n  };\n\n  for (var i = 0; i < format.length; i++) {\n    var char = format[i];\n    var isEscapeChar = \"'\" === char;\n    var regexpPart = PATTERN_REGEXPS[char];\n\n    if (isEscapeChar) {\n      isEscaping = !isEscaping;\n\n      if (\"'\" !== format[i - 1]) {\n        continue;\n      }\n    }\n\n    if (regexpPart && !isEscaping) {\n      var count = getSameCharCount(format, i);\n      var pattern = createPattern(char, count);\n      addPreviousStub();\n      patterns.push(pattern);\n      regexpText += \"(\" + regexpPart(count, dateParts) + \")\";\n      i += count - 1;\n    } else {\n      if (!stubText) {\n        regexpText += \"(\";\n      }\n\n      stubText += char;\n    }\n  }\n\n  addPreviousStub();\n  return {\n    patterns: patterns,\n    regexp: new RegExp(\"^\" + regexpText + \"$\", \"i\")\n  };\n};\n\nexports.getRegExpInfo = getRegExpInfo;\n\nvar getPatternSetters = function () {\n  return PATTERN_SETTERS;\n};\n\nexports.getPatternSetters = getPatternSetters;\n\nvar setPatternPart = function (date, pattern, text, dateParts, datePartValues) {\n  var patternChar = pattern[0];\n  var partSetter = PATTERN_SETTERS[patternChar];\n  var partParser = PATTERN_PARSERS[patternChar];\n\n  if (partSetter && partParser) {\n    var value = partParser(text, pattern.length, dateParts);\n    datePartValues[pattern] = value;\n\n    if (date[partSetter]) {\n      date[partSetter](value);\n    } else {\n      partSetter(date, value, datePartValues);\n    }\n  }\n};\n\nvar setPatternPartFromNow = function (date, pattern, now) {\n  var setterName = PATTERN_SETTERS[pattern];\n  var getterName = \"g\" + setterName.substr(1);\n  var value = now[getterName]();\n  date[setterName](value);\n};\n\nvar getShortPatterns = function (fullPatterns) {\n  return fullPatterns.map(function (pattern) {\n    if (\"'\" === pattern[0]) {\n      return \"\";\n    } else {\n      return \"H\" === pattern[0] ? \"h\" : pattern[0];\n    }\n  });\n};\n\nvar getMaxOrderedPatternIndex = function (patterns) {\n  var indexes = patterns.map(function (pattern) {\n    return ORDERED_PATTERNS.indexOf(pattern);\n  });\n  return Math.max.apply(Math, indexes);\n};\n\nvar getOrderedFormatPatterns = function (formatPatterns) {\n  var otherPatterns = formatPatterns.filter(function (pattern) {\n    return ORDERED_PATTERNS.indexOf(pattern) < 0;\n  });\n  return ORDERED_PATTERNS.concat(otherPatterns);\n};\n\nvar getParser = function (format, dateParts) {\n  var regExpInfo = getRegExpInfo(format, dateParts);\n  return function (text) {\n    var regExpResult = regExpInfo.regexp.exec(text);\n\n    if (regExpResult) {\n      var now = new Date();\n      var date = new Date(now.getFullYear(), 0, 1);\n      var formatPatterns = getShortPatterns(regExpInfo.patterns);\n      var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);\n      var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);\n      var datePartValues = {};\n      orderedFormatPatterns.forEach(function (pattern, index) {\n        if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {\n          return;\n        }\n\n        var patternIndex = formatPatterns.indexOf(pattern);\n\n        if (patternIndex >= 0) {\n          var regExpPattern = regExpInfo.patterns[patternIndex];\n          var regExpText = regExpResult[patternIndex + 1];\n          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);\n        } else {\n          setPatternPartFromNow(date, pattern, now);\n        }\n      });\n      return date;\n    }\n\n    return null;\n  };\n};\n\nexports.getParser = getParser;","map":{"version":3,"sources":["C:/Smart-Virtual-Classroom/client/node_modules/devextreme/localization/ldml/date.parser.js"],"names":["exports","getParser","getPatternSetters","getRegExpInfo","_common","require","FORMAT_TYPES","monthRegExpGenerator","count","dateParts","Object","keys","map","type","getMonthNames","join","PATTERN_REGEXPS","y","M","L","Q","getQuarterNames","E","a","getPeriodNames","d","H","h","m","s","S","w","parseNumber","Number","caseInsensitiveIndexOf","array","value","item","toLowerCase","indexOf","monthPatternParser","text","monthNames","reduce","b","concat","filter","index","PATTERN_PARSERS","year","dayNames","getDayNames","periodNames","Math","max","slice","ORDERED_PATTERNS","PATTERN_SETTERS","date","datePartValues","hours","getHours","hourPartValue","setHours","getSameCharCount","char","createPattern","result","i","format","regexpText","stubText","isEscaping","patterns","addPreviousStub","push","escapeRegExp","length","isEscapeChar","regexpPart","pattern","regexp","RegExp","setPatternPart","patternChar","partSetter","partParser","setPatternPartFromNow","now","setterName","getterName","substr","getShortPatterns","fullPatterns","getMaxOrderedPatternIndex","indexes","apply","getOrderedFormatPatterns","formatPatterns","otherPatterns","regExpInfo","regExpResult","exec","Date","getFullYear","maxPatternIndex","orderedFormatPatterns","forEach","patternIndex","regExpPattern","regExpText"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (localization/ldml/date.parser.js)\r\n * Version: 20.2.7\r\n * Build date: Thu Apr 22 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nexports.getParser = exports.getPatternSetters = exports.getRegExpInfo = void 0;\r\nvar _common = require(\"../../core/utils/common\");\r\nvar FORMAT_TYPES = {\r\n    3: \"abbreviated\",\r\n    4: \"wide\",\r\n    5: \"narrow\"\r\n};\r\nvar monthRegExpGenerator = function(count, dateParts) {\r\n    if (count > 2) {\r\n        return Object.keys(FORMAT_TYPES).map(function(count) {\r\n            return [\"format\", \"standalone\"].map(function(type) {\r\n                return dateParts.getMonthNames(FORMAT_TYPES[count], type).join(\"|\")\r\n            }).join(\"|\")\r\n        }).join(\"|\")\r\n    }\r\n    return \"0?[1-9]|1[012]\"\r\n};\r\nvar PATTERN_REGEXPS = {\r\n    y: function(count) {\r\n        return \"[0-9]+\"\r\n    },\r\n    M: monthRegExpGenerator,\r\n    L: monthRegExpGenerator,\r\n    Q: function(count, dateParts) {\r\n        if (count > 2) {\r\n            return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").join(\"|\")\r\n        }\r\n        return \"0?[1-4]\"\r\n    },\r\n    E: function(count, dateParts) {\r\n        return \"\\\\D*\"\r\n    },\r\n    a: function(count, dateParts) {\r\n        return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\").join(\"|\")\r\n    },\r\n    d: function(count) {\r\n        return \"0?[1-9]|[12][0-9]|3[01]\"\r\n    },\r\n    H: function(count) {\r\n        return \"0?[0-9]|1[0-9]|2[0-3]\"\r\n    },\r\n    h: function(count) {\r\n        return \"0?[1-9]|1[012]\"\r\n    },\r\n    m: function(count) {\r\n        return \"0?[0-9]|[1-5][0-9]\"\r\n    },\r\n    s: function(count) {\r\n        return \"0?[0-9]|[1-5][0-9]\"\r\n    },\r\n    S: function(count) {\r\n        return \"[0-9]{1,\" + count + \"}\"\r\n    },\r\n    w: function(count) {\r\n        return \"0?[0-9]|[1-5][0-9]\"\r\n    }\r\n};\r\nvar parseNumber = Number;\r\nvar caseInsensitiveIndexOf = function(array, value) {\r\n    return array.map(function(item) {\r\n        return item.toLowerCase()\r\n    }).indexOf(value.toLowerCase())\r\n};\r\nvar monthPatternParser = function(text, count, dateParts) {\r\n    if (count > 2) {\r\n        return [\"format\", \"standalone\"].map(function(type) {\r\n            return Object.keys(FORMAT_TYPES).map(function(count) {\r\n                var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);\r\n                return caseInsensitiveIndexOf(monthNames, text)\r\n            })\r\n        }).reduce(function(a, b) {\r\n            return a.concat(b)\r\n        }).filter(function(index) {\r\n            return index >= 0\r\n        })[0]\r\n    }\r\n    return parseNumber(text) - 1\r\n};\r\nvar PATTERN_PARSERS = {\r\n    y: function(text, count) {\r\n        var year = parseNumber(text);\r\n        if (2 === count) {\r\n            return year < 30 ? 2e3 + year : 1900 + year\r\n        }\r\n        return year\r\n    },\r\n    M: monthPatternParser,\r\n    L: monthPatternParser,\r\n    Q: function(text, count, dateParts) {\r\n        if (count > 2) {\r\n            return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").indexOf(text)\r\n        }\r\n        return parseNumber(text) - 1\r\n    },\r\n    E: function(text, count, dateParts) {\r\n        var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\r\n        return caseInsensitiveIndexOf(dayNames, text)\r\n    },\r\n    a: function(text, count, dateParts) {\r\n        var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\r\n        return caseInsensitiveIndexOf(periodNames, text)\r\n    },\r\n    d: parseNumber,\r\n    H: parseNumber,\r\n    h: parseNumber,\r\n    m: parseNumber,\r\n    s: parseNumber,\r\n    S: function(text, count) {\r\n        count = Math.max(count, 3);\r\n        text = text.slice(0, 3);\r\n        while (count < 3) {\r\n            text += \"0\";\r\n            count++\r\n        }\r\n        return parseNumber(text)\r\n    }\r\n};\r\nvar ORDERED_PATTERNS = [\"y\", \"M\", \"d\", \"h\", \"m\", \"s\", \"S\"];\r\nvar PATTERN_SETTERS = {\r\n    y: \"setFullYear\",\r\n    M: \"setMonth\",\r\n    L: \"setMonth\",\r\n    a: function(date, value, datePartValues) {\r\n        var hours = date.getHours();\r\n        var hourPartValue = datePartValues.h;\r\n        if (void 0 !== hourPartValue && hourPartValue !== hours) {\r\n            hours--\r\n        }\r\n        if (!value && 12 === hours) {\r\n            hours = 0\r\n        } else {\r\n            if (value && 12 !== hours) {\r\n                hours += 12\r\n            }\r\n        }\r\n        date.setHours(hours)\r\n    },\r\n    d: \"setDate\",\r\n    H: \"setHours\",\r\n    h: \"setHours\",\r\n    m: \"setMinutes\",\r\n    s: \"setSeconds\",\r\n    S: \"setMilliseconds\"\r\n};\r\nvar getSameCharCount = function(text, index) {\r\n    var char = text[index];\r\n    var count = 0;\r\n    do {\r\n        index++;\r\n        count++\r\n    } while (text[index] === char);\r\n    return count\r\n};\r\nvar createPattern = function(char, count) {\r\n    var result = \"\";\r\n    for (var i = 0; i < count; i++) {\r\n        result += char\r\n    }\r\n    return result\r\n};\r\nvar getRegExpInfo = function(format, dateParts) {\r\n    var regexpText = \"\";\r\n    var stubText = \"\";\r\n    var isEscaping;\r\n    var patterns = [];\r\n    var addPreviousStub = function() {\r\n        if (stubText) {\r\n            patterns.push(\"'\" + stubText + \"'\");\r\n            regexpText += (0, _common.escapeRegExp)(stubText) + \")\";\r\n            stubText = \"\"\r\n        }\r\n    };\r\n    for (var i = 0; i < format.length; i++) {\r\n        var char = format[i];\r\n        var isEscapeChar = \"'\" === char;\r\n        var regexpPart = PATTERN_REGEXPS[char];\r\n        if (isEscapeChar) {\r\n            isEscaping = !isEscaping;\r\n            if (\"'\" !== format[i - 1]) {\r\n                continue\r\n            }\r\n        }\r\n        if (regexpPart && !isEscaping) {\r\n            var count = getSameCharCount(format, i);\r\n            var pattern = createPattern(char, count);\r\n            addPreviousStub();\r\n            patterns.push(pattern);\r\n            regexpText += \"(\" + regexpPart(count, dateParts) + \")\";\r\n            i += count - 1\r\n        } else {\r\n            if (!stubText) {\r\n                regexpText += \"(\"\r\n            }\r\n            stubText += char\r\n        }\r\n    }\r\n    addPreviousStub();\r\n    return {\r\n        patterns: patterns,\r\n        regexp: new RegExp(\"^\" + regexpText + \"$\", \"i\")\r\n    }\r\n};\r\nexports.getRegExpInfo = getRegExpInfo;\r\nvar getPatternSetters = function() {\r\n    return PATTERN_SETTERS\r\n};\r\nexports.getPatternSetters = getPatternSetters;\r\nvar setPatternPart = function(date, pattern, text, dateParts, datePartValues) {\r\n    var patternChar = pattern[0];\r\n    var partSetter = PATTERN_SETTERS[patternChar];\r\n    var partParser = PATTERN_PARSERS[patternChar];\r\n    if (partSetter && partParser) {\r\n        var value = partParser(text, pattern.length, dateParts);\r\n        datePartValues[pattern] = value;\r\n        if (date[partSetter]) {\r\n            date[partSetter](value)\r\n        } else {\r\n            partSetter(date, value, datePartValues)\r\n        }\r\n    }\r\n};\r\nvar setPatternPartFromNow = function(date, pattern, now) {\r\n    var setterName = PATTERN_SETTERS[pattern];\r\n    var getterName = \"g\" + setterName.substr(1);\r\n    var value = now[getterName]();\r\n    date[setterName](value)\r\n};\r\nvar getShortPatterns = function(fullPatterns) {\r\n    return fullPatterns.map(function(pattern) {\r\n        if (\"'\" === pattern[0]) {\r\n            return \"\"\r\n        } else {\r\n            return \"H\" === pattern[0] ? \"h\" : pattern[0]\r\n        }\r\n    })\r\n};\r\nvar getMaxOrderedPatternIndex = function(patterns) {\r\n    var indexes = patterns.map(function(pattern) {\r\n        return ORDERED_PATTERNS.indexOf(pattern)\r\n    });\r\n    return Math.max.apply(Math, indexes)\r\n};\r\nvar getOrderedFormatPatterns = function(formatPatterns) {\r\n    var otherPatterns = formatPatterns.filter(function(pattern) {\r\n        return ORDERED_PATTERNS.indexOf(pattern) < 0\r\n    });\r\n    return ORDERED_PATTERNS.concat(otherPatterns)\r\n};\r\nvar getParser = function(format, dateParts) {\r\n    var regExpInfo = getRegExpInfo(format, dateParts);\r\n    return function(text) {\r\n        var regExpResult = regExpInfo.regexp.exec(text);\r\n        if (regExpResult) {\r\n            var now = new Date;\r\n            var date = new Date(now.getFullYear(), 0, 1);\r\n            var formatPatterns = getShortPatterns(regExpInfo.patterns);\r\n            var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);\r\n            var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);\r\n            var datePartValues = {};\r\n            orderedFormatPatterns.forEach(function(pattern, index) {\r\n                if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {\r\n                    return\r\n                }\r\n                var patternIndex = formatPatterns.indexOf(pattern);\r\n                if (patternIndex >= 0) {\r\n                    var regExpPattern = regExpInfo.patterns[patternIndex];\r\n                    var regExpText = regExpResult[patternIndex + 1];\r\n                    setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues)\r\n                } else {\r\n                    setPatternPartFromNow(date, pattern, now)\r\n                }\r\n            });\r\n            return date\r\n        }\r\n        return null\r\n    }\r\n};\r\nexports.getParser = getParser;\r\n"]},"metadata":{},"sourceType":"script"}