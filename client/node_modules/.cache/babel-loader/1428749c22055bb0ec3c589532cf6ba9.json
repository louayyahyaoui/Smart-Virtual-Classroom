{"ast":null,"code":"var bufferEqual = require('buffer-equal-constant-time');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar crypto = require('crypto');\n\nvar formatEcdsa = require('ecdsa-sig-formatter');\n\nvar util = require('util');\n\nvar MSG_INVALID_ALGORITHM = '\"%s\" is not a valid algorithm.\\n  Supported algorithms are:\\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".';\nvar MSG_INVALID_SECRET = 'secret must be a string or buffer';\nvar MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';\nvar MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';\nvar supportsKeyObjects = typeof crypto.createPublicKey === 'function';\n\nif (supportsKeyObjects) {\n  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';\n  MSG_INVALID_SECRET += 'or a KeyObject';\n}\n\nfunction checkIsPublicKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return;\n  }\n\n  if (!supportsKeyObjects) {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key !== 'object') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.type !== 'string') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.asymmetricKeyType !== 'string') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.export !== 'function') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n}\n\n;\n\nfunction checkIsPrivateKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return;\n  }\n\n  if (typeof key === 'object') {\n    return;\n  }\n\n  throw typeError(MSG_INVALID_SIGNER_KEY);\n}\n\n;\n\nfunction checkIsSecretKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return key;\n  }\n\n  if (!supportsKeyObjects) {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (typeof key !== 'object') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (key.type !== 'secret') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (typeof key.export !== 'function') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n}\n\nfunction fromBase64(base64) {\n  return base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\nfunction toBase64(base64url) {\n  base64url = base64url.toString();\n  var padding = 4 - base64url.length % 4;\n\n  if (padding !== 4) {\n    for (var i = 0; i < padding; ++i) {\n      base64url += '=';\n    }\n  }\n\n  return base64url.replace(/\\-/g, '+').replace(/_/g, '/');\n}\n\nfunction typeError(template) {\n  var args = [].slice.call(arguments, 1);\n  var errMsg = util.format.bind(util, template).apply(null, args);\n  return new TypeError(errMsg);\n}\n\nfunction bufferOrString(obj) {\n  return Buffer.isBuffer(obj) || typeof obj === 'string';\n}\n\nfunction normalizeInput(thing) {\n  if (!bufferOrString(thing)) thing = JSON.stringify(thing);\n  return thing;\n}\n\nfunction createHmacSigner(bits) {\n  return function sign(thing, secret) {\n    checkIsSecretKey(secret);\n    thing = normalizeInput(thing);\n    var hmac = crypto.createHmac('sha' + bits, secret);\n    var sig = (hmac.update(thing), hmac.digest('base64'));\n    return fromBase64(sig);\n  };\n}\n\nfunction createHmacVerifier(bits) {\n  return function verify(thing, signature, secret) {\n    var computedSig = createHmacSigner(bits)(thing, secret);\n    return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));\n  };\n}\n\nfunction createKeySigner(bits) {\n  return function sign(thing, privateKey) {\n    checkIsPrivateKey(privateKey);\n    thing = normalizeInput(thing); // Even though we are specifying \"RSA\" here, this works with ECDSA\n    // keys as well.\n\n    var signer = crypto.createSign('RSA-SHA' + bits);\n    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));\n    return fromBase64(sig);\n  };\n}\n\nfunction createKeyVerifier(bits) {\n  return function verify(thing, signature, publicKey) {\n    checkIsPublicKey(publicKey);\n    thing = normalizeInput(thing);\n    signature = toBase64(signature);\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\n    verifier.update(thing);\n    return verifier.verify(publicKey, signature, 'base64');\n  };\n}\n\nfunction createPSSKeySigner(bits) {\n  return function sign(thing, privateKey) {\n    checkIsPrivateKey(privateKey);\n    thing = normalizeInput(thing);\n    var signer = crypto.createSign('RSA-SHA' + bits);\n    var sig = (signer.update(thing), signer.sign({\n      key: privateKey,\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n    }, 'base64'));\n    return fromBase64(sig);\n  };\n}\n\nfunction createPSSKeyVerifier(bits) {\n  return function verify(thing, signature, publicKey) {\n    checkIsPublicKey(publicKey);\n    thing = normalizeInput(thing);\n    signature = toBase64(signature);\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\n    verifier.update(thing);\n    return verifier.verify({\n      key: publicKey,\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n    }, signature, 'base64');\n  };\n}\n\nfunction createECDSASigner(bits) {\n  var inner = createKeySigner(bits);\n  return function sign() {\n    var signature = inner.apply(null, arguments);\n    signature = formatEcdsa.derToJose(signature, 'ES' + bits);\n    return signature;\n  };\n}\n\nfunction createECDSAVerifer(bits) {\n  var inner = createKeyVerifier(bits);\n  return function verify(thing, signature, publicKey) {\n    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');\n    var result = inner(thing, signature, publicKey);\n    return result;\n  };\n}\n\nfunction createNoneSigner() {\n  return function sign() {\n    return '';\n  };\n}\n\nfunction createNoneVerifier() {\n  return function verify(thing, signature) {\n    return signature === '';\n  };\n}\n\nmodule.exports = function jwa(algorithm) {\n  var signerFactories = {\n    hs: createHmacSigner,\n    rs: createKeySigner,\n    ps: createPSSKeySigner,\n    es: createECDSASigner,\n    none: createNoneSigner\n  };\n  var verifierFactories = {\n    hs: createHmacVerifier,\n    rs: createKeyVerifier,\n    ps: createPSSKeyVerifier,\n    es: createECDSAVerifer,\n    none: createNoneVerifier\n  };\n  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);\n  if (!match) throw typeError(MSG_INVALID_ALGORITHM, algorithm);\n  var algo = (match[1] || match[3]).toLowerCase();\n  var bits = match[2];\n  return {\n    sign: signerFactories[algo](bits),\n    verify: verifierFactories[algo](bits)\n  };\n};","map":{"version":3,"sources":["C:/Smart-Virtual-Classroom/client/node_modules/jwa/index.js"],"names":["bufferEqual","require","Buffer","crypto","formatEcdsa","util","MSG_INVALID_ALGORITHM","MSG_INVALID_SECRET","MSG_INVALID_VERIFIER_KEY","MSG_INVALID_SIGNER_KEY","supportsKeyObjects","createPublicKey","checkIsPublicKey","key","isBuffer","typeError","type","asymmetricKeyType","export","checkIsPrivateKey","checkIsSecretKey","fromBase64","base64","replace","toBase64","base64url","toString","padding","length","i","template","args","slice","call","arguments","errMsg","format","bind","apply","TypeError","bufferOrString","obj","normalizeInput","thing","JSON","stringify","createHmacSigner","bits","sign","secret","hmac","createHmac","sig","update","digest","createHmacVerifier","verify","signature","computedSig","from","createKeySigner","privateKey","signer","createSign","createKeyVerifier","publicKey","verifier","createVerify","createPSSKeySigner","constants","RSA_PKCS1_PSS_PADDING","saltLength","RSA_PSS_SALTLEN_DIGEST","createPSSKeyVerifier","createECDSASigner","inner","derToJose","createECDSAVerifer","joseToDer","result","createNoneSigner","createNoneVerifier","module","exports","jwa","algorithm","signerFactories","hs","rs","ps","es","none","verifierFactories","match","algo","toLowerCase"],"mappings":"AAAA,IAAIA,WAAW,GAAGC,OAAO,CAAC,4BAAD,CAAzB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,aAAD,CAAP,CAAuBC,MAApC;;AACA,IAAIC,MAAM,GAAGF,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIG,WAAW,GAAGH,OAAO,CAAC,qBAAD,CAAzB;;AACA,IAAII,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAAlB;;AAEA,IAAIK,qBAAqB,GAAG,uLAA5B;AACA,IAAIC,kBAAkB,GAAG,mCAAzB;AACA,IAAIC,wBAAwB,GAAG,kCAA/B;AACA,IAAIC,sBAAsB,GAAG,6CAA7B;AAEA,IAAIC,kBAAkB,GAAG,OAAOP,MAAM,CAACQ,eAAd,KAAkC,UAA3D;;AACA,IAAID,kBAAJ,EAAwB;AACtBF,EAAAA,wBAAwB,IAAI,iBAA5B;AACAD,EAAAA,kBAAkB,IAAI,gBAAtB;AACD;;AAED,SAASK,gBAAT,CAA0BC,GAA1B,EAA+B;AAC7B,MAAIX,MAAM,CAACY,QAAP,CAAgBD,GAAhB,CAAJ,EAA0B;AACxB;AACD;;AAED,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B;AACD;;AAED,MAAI,CAACH,kBAAL,EAAyB;AACvB,UAAMK,SAAS,CAACP,wBAAD,CAAf;AACD;;AAED,MAAI,OAAOK,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAME,SAAS,CAACP,wBAAD,CAAf;AACD;;AAED,MAAI,OAAOK,GAAG,CAACG,IAAX,KAAoB,QAAxB,EAAkC;AAChC,UAAMD,SAAS,CAACP,wBAAD,CAAf;AACD;;AAED,MAAI,OAAOK,GAAG,CAACI,iBAAX,KAAiC,QAArC,EAA+C;AAC7C,UAAMF,SAAS,CAACP,wBAAD,CAAf;AACD;;AAED,MAAI,OAAOK,GAAG,CAACK,MAAX,KAAsB,UAA1B,EAAsC;AACpC,UAAMH,SAAS,CAACP,wBAAD,CAAf;AACD;AACF;;AAAA;;AAED,SAASW,iBAAT,CAA2BN,GAA3B,EAAgC;AAC9B,MAAIX,MAAM,CAACY,QAAP,CAAgBD,GAAhB,CAAJ,EAA0B;AACxB;AACD;;AAED,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B;AACD;;AAED,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B;AACD;;AAED,QAAME,SAAS,CAACN,sBAAD,CAAf;AACD;;AAAA;;AAED,SAASW,gBAAT,CAA0BP,GAA1B,EAA+B;AAC7B,MAAIX,MAAM,CAACY,QAAP,CAAgBD,GAAhB,CAAJ,EAA0B;AACxB;AACD;;AAED,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAOA,GAAP;AACD;;AAED,MAAI,CAACH,kBAAL,EAAyB;AACvB,UAAMK,SAAS,CAACR,kBAAD,CAAf;AACD;;AAED,MAAI,OAAOM,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAME,SAAS,CAACR,kBAAD,CAAf;AACD;;AAED,MAAIM,GAAG,CAACG,IAAJ,KAAa,QAAjB,EAA2B;AACzB,UAAMD,SAAS,CAACR,kBAAD,CAAf;AACD;;AAED,MAAI,OAAOM,GAAG,CAACK,MAAX,KAAsB,UAA1B,EAAsC;AACpC,UAAMH,SAAS,CAACR,kBAAD,CAAf;AACD;AACF;;AAED,SAASc,UAAT,CAAoBC,MAApB,EAA4B;AAC1B,SAAOA,MAAM,CACVC,OADI,CACI,IADJ,EACU,EADV,EAEJA,OAFI,CAEI,KAFJ,EAEW,GAFX,EAGJA,OAHI,CAGI,KAHJ,EAGW,GAHX,CAAP;AAID;;AAED,SAASC,QAAT,CAAkBC,SAAlB,EAA6B;AAC3BA,EAAAA,SAAS,GAAGA,SAAS,CAACC,QAAV,EAAZ;AAEA,MAAIC,OAAO,GAAG,IAAIF,SAAS,CAACG,MAAV,GAAmB,CAArC;;AACA,MAAID,OAAO,KAAK,CAAhB,EAAmB;AACjB,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAApB,EAA6B,EAAEE,CAA/B,EAAkC;AAChCJ,MAAAA,SAAS,IAAI,GAAb;AACD;AACF;;AAED,SAAOA,SAAS,CACbF,OADI,CACI,KADJ,EACW,GADX,EAEJA,OAFI,CAEI,IAFJ,EAEU,GAFV,CAAP;AAGD;;AAED,SAASR,SAAT,CAAmBe,QAAnB,EAA6B;AAC3B,MAAIC,IAAI,GAAG,GAAGC,KAAH,CAASC,IAAT,CAAcC,SAAd,EAAyB,CAAzB,CAAX;AACA,MAAIC,MAAM,GAAG9B,IAAI,CAAC+B,MAAL,CAAYC,IAAZ,CAAiBhC,IAAjB,EAAuByB,QAAvB,EAAiCQ,KAAjC,CAAuC,IAAvC,EAA6CP,IAA7C,CAAb;AACA,SAAO,IAAIQ,SAAJ,CAAcJ,MAAd,CAAP;AACD;;AAED,SAASK,cAAT,CAAwBC,GAAxB,EAA6B;AAC3B,SAAOvC,MAAM,CAACY,QAAP,CAAgB2B,GAAhB,KAAwB,OAAOA,GAAP,KAAe,QAA9C;AACD;;AAED,SAASC,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,MAAI,CAACH,cAAc,CAACG,KAAD,CAAnB,EACEA,KAAK,GAAGC,IAAI,CAACC,SAAL,CAAeF,KAAf,CAAR;AACF,SAAOA,KAAP;AACD;;AAED,SAASG,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,SAAO,SAASC,IAAT,CAAcL,KAAd,EAAqBM,MAArB,EAA6B;AAClC7B,IAAAA,gBAAgB,CAAC6B,MAAD,CAAhB;AACAN,IAAAA,KAAK,GAAGD,cAAc,CAACC,KAAD,CAAtB;AACA,QAAIO,IAAI,GAAG/C,MAAM,CAACgD,UAAP,CAAkB,QAAQJ,IAA1B,EAAgCE,MAAhC,CAAX;AACA,QAAIG,GAAG,IAAIF,IAAI,CAACG,MAAL,CAAYV,KAAZ,GAAoBO,IAAI,CAACI,MAAL,CAAY,QAAZ,CAAxB,CAAP;AACA,WAAOjC,UAAU,CAAC+B,GAAD,CAAjB;AACD,GAND;AAOD;;AAED,SAASG,kBAAT,CAA4BR,IAA5B,EAAkC;AAChC,SAAO,SAASS,MAAT,CAAgBb,KAAhB,EAAuBc,SAAvB,EAAkCR,MAAlC,EAA0C;AAC/C,QAAIS,WAAW,GAAGZ,gBAAgB,CAACC,IAAD,CAAhB,CAAuBJ,KAAvB,EAA8BM,MAA9B,CAAlB;AACA,WAAOjD,WAAW,CAACE,MAAM,CAACyD,IAAP,CAAYF,SAAZ,CAAD,EAAyBvD,MAAM,CAACyD,IAAP,CAAYD,WAAZ,CAAzB,CAAlB;AACD,GAHD;AAID;;AAED,SAASE,eAAT,CAAyBb,IAAzB,EAA+B;AAC9B,SAAO,SAASC,IAAT,CAAcL,KAAd,EAAqBkB,UAArB,EAAiC;AACrC1C,IAAAA,iBAAiB,CAAC0C,UAAD,CAAjB;AACAlB,IAAAA,KAAK,GAAGD,cAAc,CAACC,KAAD,CAAtB,CAFqC,CAGrC;AACA;;AACA,QAAImB,MAAM,GAAG3D,MAAM,CAAC4D,UAAP,CAAkB,YAAYhB,IAA9B,CAAb;AACA,QAAIK,GAAG,IAAIU,MAAM,CAACT,MAAP,CAAcV,KAAd,GAAsBmB,MAAM,CAACd,IAAP,CAAYa,UAAZ,EAAwB,QAAxB,CAA1B,CAAP;AACA,WAAOxC,UAAU,CAAC+B,GAAD,CAAjB;AACD,GARF;AASA;;AAED,SAASY,iBAAT,CAA2BjB,IAA3B,EAAiC;AAC/B,SAAO,SAASS,MAAT,CAAgBb,KAAhB,EAAuBc,SAAvB,EAAkCQ,SAAlC,EAA6C;AAClDrD,IAAAA,gBAAgB,CAACqD,SAAD,CAAhB;AACAtB,IAAAA,KAAK,GAAGD,cAAc,CAACC,KAAD,CAAtB;AACAc,IAAAA,SAAS,GAAGjC,QAAQ,CAACiC,SAAD,CAApB;AACA,QAAIS,QAAQ,GAAG/D,MAAM,CAACgE,YAAP,CAAoB,YAAYpB,IAAhC,CAAf;AACAmB,IAAAA,QAAQ,CAACb,MAAT,CAAgBV,KAAhB;AACA,WAAOuB,QAAQ,CAACV,MAAT,CAAgBS,SAAhB,EAA2BR,SAA3B,EAAsC,QAAtC,CAAP;AACD,GAPD;AAQD;;AAED,SAASW,kBAAT,CAA4BrB,IAA5B,EAAkC;AAChC,SAAO,SAASC,IAAT,CAAcL,KAAd,EAAqBkB,UAArB,EAAiC;AACtC1C,IAAAA,iBAAiB,CAAC0C,UAAD,CAAjB;AACAlB,IAAAA,KAAK,GAAGD,cAAc,CAACC,KAAD,CAAtB;AACA,QAAImB,MAAM,GAAG3D,MAAM,CAAC4D,UAAP,CAAkB,YAAYhB,IAA9B,CAAb;AACA,QAAIK,GAAG,IAAIU,MAAM,CAACT,MAAP,CAAcV,KAAd,GAAsBmB,MAAM,CAACd,IAAP,CAAY;AAC3CnC,MAAAA,GAAG,EAAEgD,UADsC;AAE3ClC,MAAAA,OAAO,EAAExB,MAAM,CAACkE,SAAP,CAAiBC,qBAFiB;AAG3CC,MAAAA,UAAU,EAAEpE,MAAM,CAACkE,SAAP,CAAiBG;AAHc,KAAZ,EAI9B,QAJ8B,CAA1B,CAAP;AAKA,WAAOnD,UAAU,CAAC+B,GAAD,CAAjB;AACD,GAVD;AAWD;;AAED,SAASqB,oBAAT,CAA8B1B,IAA9B,EAAoC;AAClC,SAAO,SAASS,MAAT,CAAgBb,KAAhB,EAAuBc,SAAvB,EAAkCQ,SAAlC,EAA6C;AAClDrD,IAAAA,gBAAgB,CAACqD,SAAD,CAAhB;AACAtB,IAAAA,KAAK,GAAGD,cAAc,CAACC,KAAD,CAAtB;AACAc,IAAAA,SAAS,GAAGjC,QAAQ,CAACiC,SAAD,CAApB;AACA,QAAIS,QAAQ,GAAG/D,MAAM,CAACgE,YAAP,CAAoB,YAAYpB,IAAhC,CAAf;AACAmB,IAAAA,QAAQ,CAACb,MAAT,CAAgBV,KAAhB;AACA,WAAOuB,QAAQ,CAACV,MAAT,CAAgB;AACrB3C,MAAAA,GAAG,EAAEoD,SADgB;AAErBtC,MAAAA,OAAO,EAAExB,MAAM,CAACkE,SAAP,CAAiBC,qBAFL;AAGrBC,MAAAA,UAAU,EAAEpE,MAAM,CAACkE,SAAP,CAAiBG;AAHR,KAAhB,EAIJf,SAJI,EAIO,QAJP,CAAP;AAKD,GAXD;AAYD;;AAED,SAASiB,iBAAT,CAA2B3B,IAA3B,EAAiC;AAC/B,MAAI4B,KAAK,GAAGf,eAAe,CAACb,IAAD,CAA3B;AACA,SAAO,SAASC,IAAT,GAAgB;AACrB,QAAIS,SAAS,GAAGkB,KAAK,CAACrC,KAAN,CAAY,IAAZ,EAAkBJ,SAAlB,CAAhB;AACAuB,IAAAA,SAAS,GAAGrD,WAAW,CAACwE,SAAZ,CAAsBnB,SAAtB,EAAiC,OAAOV,IAAxC,CAAZ;AACA,WAAOU,SAAP;AACD,GAJD;AAKD;;AAED,SAASoB,kBAAT,CAA4B9B,IAA5B,EAAkC;AAChC,MAAI4B,KAAK,GAAGX,iBAAiB,CAACjB,IAAD,CAA7B;AACA,SAAO,SAASS,MAAT,CAAgBb,KAAhB,EAAuBc,SAAvB,EAAkCQ,SAAlC,EAA6C;AAClDR,IAAAA,SAAS,GAAGrD,WAAW,CAAC0E,SAAZ,CAAsBrB,SAAtB,EAAiC,OAAOV,IAAxC,EAA8CrB,QAA9C,CAAuD,QAAvD,CAAZ;AACA,QAAIqD,MAAM,GAAGJ,KAAK,CAAChC,KAAD,EAAQc,SAAR,EAAmBQ,SAAnB,CAAlB;AACA,WAAOc,MAAP;AACD,GAJD;AAKD;;AAED,SAASC,gBAAT,GAA4B;AAC1B,SAAO,SAAShC,IAAT,GAAgB;AACrB,WAAO,EAAP;AACD,GAFD;AAGD;;AAED,SAASiC,kBAAT,GAA8B;AAC5B,SAAO,SAASzB,MAAT,CAAgBb,KAAhB,EAAuBc,SAAvB,EAAkC;AACvC,WAAOA,SAAS,KAAK,EAArB;AACD,GAFD;AAGD;;AAEDyB,MAAM,CAACC,OAAP,GAAiB,SAASC,GAAT,CAAaC,SAAb,EAAwB;AACvC,MAAIC,eAAe,GAAG;AACpBC,IAAAA,EAAE,EAAEzC,gBADgB;AAEpB0C,IAAAA,EAAE,EAAE5B,eAFgB;AAGpB6B,IAAAA,EAAE,EAAErB,kBAHgB;AAIpBsB,IAAAA,EAAE,EAAEhB,iBAJgB;AAKpBiB,IAAAA,IAAI,EAAEX;AALc,GAAtB;AAOA,MAAIY,iBAAiB,GAAG;AACtBL,IAAAA,EAAE,EAAEhC,kBADkB;AAEtBiC,IAAAA,EAAE,EAAExB,iBAFkB;AAGtByB,IAAAA,EAAE,EAAEhB,oBAHkB;AAItBiB,IAAAA,EAAE,EAAEb,kBAJkB;AAKtBc,IAAAA,IAAI,EAAEV;AALgB,GAAxB;AAOA,MAAIY,KAAK,GAAGR,SAAS,CAACQ,KAAV,CAAgB,wCAAhB,CAAZ;AACA,MAAI,CAACA,KAAL,EACE,MAAM9E,SAAS,CAACT,qBAAD,EAAwB+E,SAAxB,CAAf;AACF,MAAIS,IAAI,GAAG,CAACD,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAlB,EAAuBE,WAAvB,EAAX;AACA,MAAIhD,IAAI,GAAG8C,KAAK,CAAC,CAAD,CAAhB;AAEA,SAAO;AACL7C,IAAAA,IAAI,EAAEsC,eAAe,CAACQ,IAAD,CAAf,CAAsB/C,IAAtB,CADD;AAELS,IAAAA,MAAM,EAAEoC,iBAAiB,CAACE,IAAD,CAAjB,CAAwB/C,IAAxB;AAFH,GAAP;AAID,CAzBD","sourcesContent":["var bufferEqual = require('buffer-equal-constant-time');\nvar Buffer = require('safe-buffer').Buffer;\nvar crypto = require('crypto');\nvar formatEcdsa = require('ecdsa-sig-formatter');\nvar util = require('util');\n\nvar MSG_INVALID_ALGORITHM = '\"%s\" is not a valid algorithm.\\n  Supported algorithms are:\\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".'\nvar MSG_INVALID_SECRET = 'secret must be a string or buffer';\nvar MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';\nvar MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';\n\nvar supportsKeyObjects = typeof crypto.createPublicKey === 'function';\nif (supportsKeyObjects) {\n  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';\n  MSG_INVALID_SECRET += 'or a KeyObject';\n}\n\nfunction checkIsPublicKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return;\n  }\n\n  if (!supportsKeyObjects) {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key !== 'object') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.type !== 'string') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.asymmetricKeyType !== 'string') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.export !== 'function') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n};\n\nfunction checkIsPrivateKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return;\n  }\n\n  if (typeof key === 'object') {\n    return;\n  }\n\n  throw typeError(MSG_INVALID_SIGNER_KEY);\n};\n\nfunction checkIsSecretKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return key;\n  }\n\n  if (!supportsKeyObjects) {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (typeof key !== 'object') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (key.type !== 'secret') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (typeof key.export !== 'function') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n}\n\nfunction fromBase64(base64) {\n  return base64\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n\nfunction toBase64(base64url) {\n  base64url = base64url.toString();\n\n  var padding = 4 - base64url.length % 4;\n  if (padding !== 4) {\n    for (var i = 0; i < padding; ++i) {\n      base64url += '=';\n    }\n  }\n\n  return base64url\n    .replace(/\\-/g, '+')\n    .replace(/_/g, '/');\n}\n\nfunction typeError(template) {\n  var args = [].slice.call(arguments, 1);\n  var errMsg = util.format.bind(util, template).apply(null, args);\n  return new TypeError(errMsg);\n}\n\nfunction bufferOrString(obj) {\n  return Buffer.isBuffer(obj) || typeof obj === 'string';\n}\n\nfunction normalizeInput(thing) {\n  if (!bufferOrString(thing))\n    thing = JSON.stringify(thing);\n  return thing;\n}\n\nfunction createHmacSigner(bits) {\n  return function sign(thing, secret) {\n    checkIsSecretKey(secret);\n    thing = normalizeInput(thing);\n    var hmac = crypto.createHmac('sha' + bits, secret);\n    var sig = (hmac.update(thing), hmac.digest('base64'))\n    return fromBase64(sig);\n  }\n}\n\nfunction createHmacVerifier(bits) {\n  return function verify(thing, signature, secret) {\n    var computedSig = createHmacSigner(bits)(thing, secret);\n    return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));\n  }\n}\n\nfunction createKeySigner(bits) {\n return function sign(thing, privateKey) {\n    checkIsPrivateKey(privateKey);\n    thing = normalizeInput(thing);\n    // Even though we are specifying \"RSA\" here, this works with ECDSA\n    // keys as well.\n    var signer = crypto.createSign('RSA-SHA' + bits);\n    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));\n    return fromBase64(sig);\n  }\n}\n\nfunction createKeyVerifier(bits) {\n  return function verify(thing, signature, publicKey) {\n    checkIsPublicKey(publicKey);\n    thing = normalizeInput(thing);\n    signature = toBase64(signature);\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\n    verifier.update(thing);\n    return verifier.verify(publicKey, signature, 'base64');\n  }\n}\n\nfunction createPSSKeySigner(bits) {\n  return function sign(thing, privateKey) {\n    checkIsPrivateKey(privateKey);\n    thing = normalizeInput(thing);\n    var signer = crypto.createSign('RSA-SHA' + bits);\n    var sig = (signer.update(thing), signer.sign({\n      key: privateKey,\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n    }, 'base64'));\n    return fromBase64(sig);\n  }\n}\n\nfunction createPSSKeyVerifier(bits) {\n  return function verify(thing, signature, publicKey) {\n    checkIsPublicKey(publicKey);\n    thing = normalizeInput(thing);\n    signature = toBase64(signature);\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\n    verifier.update(thing);\n    return verifier.verify({\n      key: publicKey,\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n    }, signature, 'base64');\n  }\n}\n\nfunction createECDSASigner(bits) {\n  var inner = createKeySigner(bits);\n  return function sign() {\n    var signature = inner.apply(null, arguments);\n    signature = formatEcdsa.derToJose(signature, 'ES' + bits);\n    return signature;\n  };\n}\n\nfunction createECDSAVerifer(bits) {\n  var inner = createKeyVerifier(bits);\n  return function verify(thing, signature, publicKey) {\n    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');\n    var result = inner(thing, signature, publicKey);\n    return result;\n  };\n}\n\nfunction createNoneSigner() {\n  return function sign() {\n    return '';\n  }\n}\n\nfunction createNoneVerifier() {\n  return function verify(thing, signature) {\n    return signature === '';\n  }\n}\n\nmodule.exports = function jwa(algorithm) {\n  var signerFactories = {\n    hs: createHmacSigner,\n    rs: createKeySigner,\n    ps: createPSSKeySigner,\n    es: createECDSASigner,\n    none: createNoneSigner,\n  }\n  var verifierFactories = {\n    hs: createHmacVerifier,\n    rs: createKeyVerifier,\n    ps: createPSSKeyVerifier,\n    es: createECDSAVerifer,\n    none: createNoneVerifier,\n  }\n  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);\n  if (!match)\n    throw typeError(MSG_INVALID_ALGORITHM, algorithm);\n  var algo = (match[1] || match[3]).toLowerCase();\n  var bits = match[2];\n\n  return {\n    sign: signerFactories[algo](bits),\n    verify: verifierFactories[algo](bits),\n  }\n};\n"]},"metadata":{},"sourceType":"script"}