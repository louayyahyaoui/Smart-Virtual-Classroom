{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar getParamBytesForAlg = require('./param-bytes-for-alg');\n\nvar MAX_OCTET = 0x80,\n    CLASS_UNIVERSAL = 0,\n    PRIMITIVE_BIT = 0x20,\n    TAG_SEQ = 0x10,\n    TAG_INT = 0x02,\n    ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6,\n    ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\n\nfunction base64Url(base64) {\n  return base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\nfunction signatureAsBuffer(signature) {\n  if (Buffer.isBuffer(signature)) {\n    return signature;\n  } else if ('string' === typeof signature) {\n    return Buffer.from(signature, 'base64');\n  }\n\n  throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');\n}\n\nfunction derToJose(signature, alg) {\n  signature = signatureAsBuffer(signature);\n  var paramBytes = getParamBytesForAlg(alg); // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n\n  var maxEncodedParamLength = paramBytes + 1;\n  var inputLength = signature.length;\n  var offset = 0;\n\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"');\n  }\n\n  var seqLength = signature[offset++];\n\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++];\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error('\"seq\" specified length of \"' + seqLength + '\", only \"' + (inputLength - offset) + '\" remaining');\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  }\n\n  var rLength = signature[offset++];\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error('\"r\" specified length of \"' + rLength + '\", only \"' + (inputLength - offset - 2) + '\" available');\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error('\"r\" specified length of \"' + rLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n  }\n\n  var rOffset = offset;\n  offset += rLength;\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  }\n\n  var sLength = signature[offset++];\n\n  if (inputLength - offset !== sLength) {\n    throw new Error('\"s\" specified length of \"' + sLength + '\", expected \"' + (inputLength - offset) + '\"');\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error('\"s\" specified length of \"' + sLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n  }\n\n  var sOffset = offset;\n  offset += sLength;\n\n  if (offset !== inputLength) {\n    throw new Error('Expected to consume entire buffer, but \"' + (inputLength - offset) + '\" bytes remain');\n  }\n\n  var rPadding = paramBytes - rLength,\n      sPadding = paramBytes - sLength;\n  var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n  offset = paramBytes;\n\n  for (var o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n  dst = dst.toString('base64');\n  dst = base64Url(dst);\n  return dst;\n}\n\nfunction countPadding(buf, start, stop) {\n  var padding = 0;\n\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n\n  var needsSign = buf[start + padding] >= MAX_OCTET;\n\n  if (needsSign) {\n    --padding;\n  }\n\n  return padding;\n}\n\nfunction joseToDer(signature, alg) {\n  signature = signatureAsBuffer(signature);\n  var paramBytes = getParamBytesForAlg(alg);\n  var signatureBytes = signature.length;\n\n  if (signatureBytes !== paramBytes * 2) {\n    throw new TypeError('\"' + alg + '\" signatures must be \"' + paramBytes * 2 + '\" bytes, saw \"' + signatureBytes + '\"');\n  }\n\n  var rPadding = countPadding(signature, 0, paramBytes);\n  var sPadding = countPadding(signature, paramBytes, signature.length);\n  var rLength = paramBytes - rPadding;\n  var sLength = paramBytes - sPadding;\n  var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n  var shortLength = rsBytes < MAX_OCTET;\n  var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  dst[offset++] = ENCODED_TAG_SEQ;\n\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes;\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET | 1; // length, base 256\n\n    dst[offset++] = rsBytes & 0xff;\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = rLength;\n\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, paramBytes);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes);\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = sLength;\n\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, paramBytes);\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding);\n  }\n\n  return dst;\n}\n\nmodule.exports = {\n  derToJose: derToJose,\n  joseToDer: joseToDer\n};","map":{"version":3,"sources":["C:/Smart-Virtual-Classroom/client/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"],"names":["Buffer","require","getParamBytesForAlg","MAX_OCTET","CLASS_UNIVERSAL","PRIMITIVE_BIT","TAG_SEQ","TAG_INT","ENCODED_TAG_SEQ","ENCODED_TAG_INT","base64Url","base64","replace","signatureAsBuffer","signature","isBuffer","from","TypeError","derToJose","alg","paramBytes","maxEncodedParamLength","inputLength","length","offset","Error","seqLength","rLength","rOffset","sLength","sOffset","rPadding","sPadding","dst","allocUnsafe","copy","Math","max","o","toString","countPadding","buf","start","stop","padding","needsSign","joseToDer","signatureBytes","rsBytes","shortLength","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar getParamBytesForAlg = require('./param-bytes-for-alg');\n\nvar MAX_OCTET = 0x80,\n\tCLASS_UNIVERSAL = 0,\n\tPRIMITIVE_BIT = 0x20,\n\tTAG_SEQ = 0x10,\n\tTAG_INT = 0x02,\n\tENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),\n\tENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);\n\nfunction base64Url(base64) {\n\treturn base64\n\t\t.replace(/=/g, '')\n\t\t.replace(/\\+/g, '-')\n\t\t.replace(/\\//g, '_');\n}\n\nfunction signatureAsBuffer(signature) {\n\tif (Buffer.isBuffer(signature)) {\n\t\treturn signature;\n\t} else if ('string' === typeof signature) {\n\t\treturn Buffer.from(signature, 'base64');\n\t}\n\n\tthrow new TypeError('ECDSA signature must be a Base64 string or a Buffer');\n}\n\nfunction derToJose(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\t// the DER encoded param should at most be the param size, plus a padding\n\t// zero, since due to being a signed integer\n\tvar maxEncodedParamLength = paramBytes + 1;\n\n\tvar inputLength = signature.length;\n\n\tvar offset = 0;\n\tif (signature[offset++] !== ENCODED_TAG_SEQ) {\n\t\tthrow new Error('Could not find expected \"seq\"');\n\t}\n\n\tvar seqLength = signature[offset++];\n\tif (seqLength === (MAX_OCTET | 1)) {\n\t\tseqLength = signature[offset++];\n\t}\n\n\tif (inputLength - offset < seqLength) {\n\t\tthrow new Error('\"seq\" specified length of \"' + seqLength + '\", only \"' + (inputLength - offset) + '\" remaining');\n\t}\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"r\"');\n\t}\n\n\tvar rLength = signature[offset++];\n\n\tif (inputLength - offset - 2 < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", only \"' + (inputLength - offset - 2) + '\" available');\n\t}\n\n\tif (maxEncodedParamLength < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar rOffset = offset;\n\toffset += rLength;\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"s\"');\n\t}\n\n\tvar sLength = signature[offset++];\n\n\tif (inputLength - offset !== sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", expected \"' + (inputLength - offset) + '\"');\n\t}\n\n\tif (maxEncodedParamLength < sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar sOffset = offset;\n\toffset += sLength;\n\n\tif (offset !== inputLength) {\n\t\tthrow new Error('Expected to consume entire buffer, but \"' + (inputLength - offset) + '\" bytes remain');\n\t}\n\n\tvar rPadding = paramBytes - rLength,\n\t\tsPadding = paramBytes - sLength;\n\n\tvar dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n\tfor (offset = 0; offset < rPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n\n\toffset = paramBytes;\n\n\tfor (var o = offset; offset < o + sPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n\n\tdst = dst.toString('base64');\n\tdst = base64Url(dst);\n\n\treturn dst;\n}\n\nfunction countPadding(buf, start, stop) {\n\tvar padding = 0;\n\twhile (start + padding < stop && buf[start + padding] === 0) {\n\t\t++padding;\n\t}\n\n\tvar needsSign = buf[start + padding] >= MAX_OCTET;\n\tif (needsSign) {\n\t\t--padding;\n\t}\n\n\treturn padding;\n}\n\nfunction joseToDer(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\tvar signatureBytes = signature.length;\n\tif (signatureBytes !== paramBytes * 2) {\n\t\tthrow new TypeError('\"' + alg + '\" signatures must be \"' + paramBytes * 2 + '\" bytes, saw \"' + signatureBytes + '\"');\n\t}\n\n\tvar rPadding = countPadding(signature, 0, paramBytes);\n\tvar sPadding = countPadding(signature, paramBytes, signature.length);\n\tvar rLength = paramBytes - rPadding;\n\tvar sLength = paramBytes - sPadding;\n\n\tvar rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n\n\tvar shortLength = rsBytes < MAX_OCTET;\n\n\tvar dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n\n\tvar offset = 0;\n\tdst[offset++] = ENCODED_TAG_SEQ;\n\tif (shortLength) {\n\t\t// Bit 8 has value \"0\"\n\t\t// bits 7-1 give the length.\n\t\tdst[offset++] = rsBytes;\n\t} else {\n\t\t// Bit 8 of first octet has value \"1\"\n\t\t// bits 7-1 give the number of additional length octets.\n\t\tdst[offset++] = MAX_OCTET\t| 1;\n\t\t// length, base 256\n\t\tdst[offset++] = rsBytes & 0xff;\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = rLength;\n\tif (rPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\toffset += signature.copy(dst, offset, 0, paramBytes);\n\t} else {\n\t\toffset += signature.copy(dst, offset, rPadding, paramBytes);\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = sLength;\n\tif (sPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\tsignature.copy(dst, offset, paramBytes);\n\t} else {\n\t\tsignature.copy(dst, offset, paramBytes + sPadding);\n\t}\n\n\treturn dst;\n}\n\nmodule.exports = {\n\tderToJose: derToJose,\n\tjoseToDer: joseToDer\n};\n"]},"metadata":{},"sourceType":"script"}