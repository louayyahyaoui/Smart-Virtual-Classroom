{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createVerboseDateFormatter;\n\nvar _locale = require('./locale');\n\nvar _cache = require('./cache');\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar cache = new _cache2.default();\n/**\r\n * Creates verbose date formatter.\r\n * \r\n * @param {string} locale - Date formatting locale\r\n * @param {object} format - Output format\r\n * @param {string} format.day     - Day format\r\n * @param {string} format.month   - Month format\r\n * @param {string} format.year    - Year format\r\n * @param {string} format.weekday - Weekday format\r\n * @param {string} format.hour    - Hour format\r\n * @param {string} format.minute  - Minute format\r\n * @param {string} format.second  - Second format\r\n *\r\n * @returns {Function} `(date) -> string`.\r\n */\n\nfunction createVerboseDateFormatter(locales, format) {\n  // Fall back to `date.toString()` for old web browsers.\n  // https://caniuse.com/#search=intl\n  if (!(0, _locale.intlDateTimeFormatSupported)()) {\n    return function (date) {\n      return date.toString();\n    };\n  } // If none of the `locales` are supported\n  // a default system locale will be used.\n\n\n  var locale = resolveLocale(locales); // `Intl.DateTimeFormat` format caching key.\n  // E.g. `\"{\"day\":\"numeric\",\"month\":\"short\",...}\"`.\n  // Didn't benchmark what's faster:\n  // creating a new `Intl.DateTimeFormat` instance\n  // or stringifying a small JSON `format`.\n  // Perhaps strigifying JSON `format` is faster.\n\n  var formatFingerprint = JSON.stringify(format); // Get `Intl.DateTimeFormat` instance for these `locale` and `format`.\n  // (`locale` can be `undefined` therefore `String(locale)`)\n\n  var formatter = cache.get(String(locale), formatFingerprint) || cache.put(String(locale), formatFingerprint, new Intl.DateTimeFormat(locale, format)); // Return date formatter\n\n  return function (date) {\n    return formatter.format(date);\n  };\n} // Caching locale resolving for optimizing pages \n// with a lot of `<ReactTimeAgo/>` elements (say, 100 or more).\n// `Intl.DateTimeFormat.supportedLocalesOf(locales)` is not instantaneous.\n// For example, it could be 25 milliseconds for 200 calls.\n\n\nvar resolvedLocales = {};\n/**\r\n * Resolves a list of possible locales to a single (\"best fit\") supported locale.\r\n * @param  {string[]} locales\r\n * @return {string}\r\n */\n\nfunction resolveLocale(locales) {\n  var localesFingerprint = locales.toString();\n\n  if (resolvedLocales[localesFingerprint]) {\n    return resolvedLocales[localesFingerprint];\n  }\n\n  return resolvedLocales[localesFingerprint] = (0, _locale.intlDateTimeFormatSupportedLocale)(locales);\n}","map":{"version":3,"sources":["../../source/helpers/verboseDateFormatter.js"],"names":["cache","createVerboseDateFormatter","date","locale","resolveLocale","formatFingerprint","JSON","formatter","String","Intl","resolvedLocales","localesFingerprint","locales"],"mappings":";;;;;kBAwBwBC,0B;;AAxBxB,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAKA,IAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;;;;;;;;;AAEA,IAAMD,KAAAA,GAAQ,IAAA,OAAA,CAAd,OAAc,EAAd;AAEA;;;;;;;;;;;;;;;;AAee,SAAA,0BAAA,CAAA,OAAA,EAAA,MAAA,EAAqD;AACnE;AACA;AACA,MAAI,CAAC,CAAA,GAAA,OAAA,CAAL,2BAAK,GAAL,EAAoC;AACnC,WAAO,UAAA,IAAA,EAAA;AAAA,aAAQE,IAAAA,CAAR,QAAQA,EAAR;AAAP,KAAA;AACA,GALkE,CAOnE;AACA;;;AACA,MAAMC,MAAAA,GAASC,aAAAA,CAAf,OAAeA,CAAf,CATmE,CAWnE;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAAA,GAAoBC,IAAAA,CAAAA,SAAAA,CAA1B,MAA0BA,CAA1B,CAjBmE,CAmBnE;AACA;;AACA,MAAMC,SAAAA,GAAYP,KAAAA,CAAAA,GAAAA,CAAUQ,MAAAA,CAAVR,MAAUQ,CAAVR,EAAAA,iBAAAA,KACjBA,KAAAA,CAAAA,GAAAA,CAAUQ,MAAAA,CAAVR,MAAUQ,CAAVR,EAAAA,iBAAAA,EAA6C,IAAIS,IAAAA,CAAJ,cAAA,CAAA,MAAA,EAD9C,MAC8C,CAA7CT,CADD,CArBmE,CAwBnE;;AACA,SAAO,UAAA,IAAA,EAAA;AAAA,WAAQO,SAAAA,CAAAA,MAAAA,CAAR,IAAQA,CAAR;AAAP,GAAA;AACA,C,CAED;AACA;AACA;AACA;;;AACA,IAAMG,eAAAA,GAAN,EAAA;AAEA;;;;;;AAKA,SAAA,aAAA,CAAA,OAAA,EAAgC;AAC/B,MAAMC,kBAAAA,GAAqBC,OAAAA,CAA3B,QAA2BA,EAA3B;;AACA,MAAIF,eAAAA,CAAJ,kBAAIA,CAAJ,EAAyC;AACxC,WAAOA,eAAAA,CAAP,kBAAOA,CAAP;AACA;;AACD,SAAOA,eAAAA,CAAAA,kBAAAA,CAAAA,GAAsC,CAAA,GAAA,OAAA,CAAA,iCAAA,EAA7C,OAA6C,CAA7C;AACA","sourcesContent":["import {\r\n\tintlDateTimeFormatSupported,\r\n\tintlDateTimeFormatSupportedLocale\r\n} from './locale'\r\n\r\nimport Cache from './cache'\r\n\r\nconst cache = new Cache()\r\n\r\n/**\r\n * Creates verbose date formatter.\r\n * \r\n * @param {string} locale - Date formatting locale\r\n * @param {object} format - Output format\r\n * @param {string} format.day     - Day format\r\n * @param {string} format.month   - Month format\r\n * @param {string} format.year    - Year format\r\n * @param {string} format.weekday - Weekday format\r\n * @param {string} format.hour    - Hour format\r\n * @param {string} format.minute  - Minute format\r\n * @param {string} format.second  - Second format\r\n *\r\n * @returns {Function} `(date) -> string`.\r\n */\r\nexport default function createVerboseDateFormatter(locales, format) {\r\n\t// Fall back to `date.toString()` for old web browsers.\r\n\t// https://caniuse.com/#search=intl\r\n\tif (!intlDateTimeFormatSupported()) {\r\n\t\treturn date => date.toString()\r\n\t}\r\n\r\n\t// If none of the `locales` are supported\r\n\t// a default system locale will be used.\r\n\tconst locale = resolveLocale(locales)\r\n\r\n\t// `Intl.DateTimeFormat` format caching key.\r\n\t// E.g. `\"{\"day\":\"numeric\",\"month\":\"short\",...}\"`.\r\n\t// Didn't benchmark what's faster:\r\n\t// creating a new `Intl.DateTimeFormat` instance\r\n\t// or stringifying a small JSON `format`.\r\n\t// Perhaps strigifying JSON `format` is faster.\r\n\tconst formatFingerprint = JSON.stringify(format)\r\n\r\n\t// Get `Intl.DateTimeFormat` instance for these `locale` and `format`.\r\n\t// (`locale` can be `undefined` therefore `String(locale)`)\r\n\tconst formatter = cache.get(String(locale), formatFingerprint) ||\r\n\t\tcache.put(String(locale), formatFingerprint, new Intl.DateTimeFormat(locale, format))\r\n\r\n\t// Return date formatter\r\n\treturn date => formatter.format(date)\r\n}\r\n\r\n// Caching locale resolving for optimizing pages \r\n// with a lot of `<ReactTimeAgo/>` elements (say, 100 or more).\r\n// `Intl.DateTimeFormat.supportedLocalesOf(locales)` is not instantaneous.\r\n// For example, it could be 25 milliseconds for 200 calls.\r\nconst resolvedLocales = {}\r\n\r\n/**\r\n * Resolves a list of possible locales to a single (\"best fit\") supported locale.\r\n * @param  {string[]} locales\r\n * @return {string}\r\n */\r\nfunction resolveLocale(locales) {\r\n\tconst localesFingerprint = locales.toString()\r\n\tif (resolvedLocales[localesFingerprint]) {\r\n\t\treturn resolvedLocales[localesFingerprint] \r\n\t}\r\n\treturn resolvedLocales[localesFingerprint] = intlDateTimeFormatSupportedLocale(locales)\r\n}"]},"metadata":{},"sourceType":"script"}